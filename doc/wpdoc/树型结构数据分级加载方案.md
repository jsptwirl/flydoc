---
title: 树型结构数据分级加载方案
date: 2020-05-22T15:49:35
---

# 树型结构数据分级加载

处理例如组织架构，营销区域，行政区域等结构的数据

由于树形结构的搜索处理较为复杂，因此当进行搜索时，树形结构会变成为列表树结果，当搜索条件清空后，会重新展示为树形结构。

为了提升用户体验，会在数据操作中

## 相关协议

### datastructure 属性

所有需要支持处理显示树形结构的数据的控件，都应该支持该属性，例如treegrid等控件。

这类控件在触发事件时会将当前触发事件的对应的（单条）数据的 id 值

该属性有结构如下：

```json
{
  "type": "treegrid",
  ......
  "datastructure": {
    "id": "",
    "pid": "",
    "idpath": ""
  },
  ......
}
```

* id

  必填，配置数据中标识数据唯一id的字段

* pid

  必填，配置数据中标识数据父级id的字段

* idpath

  可选，配置数据中标识数据完整层级路径的字段，可用于快速定位数据；该值为空时就可能需要前端遍历数据查找。

### nestedlevel 属性

datarequest 事件新增一个 nestedlevel 属性，用于控制树形结构数据的请求

```json
{
  "type": "datarequest",
  ......
  "pagesize": "20",
  "nestedlevel": "0",
  ......
}
```

* nestedlevel

  数据嵌套层数，用于控制树形结构数据每次请求的数据层数，取值如下：

|值|说明|
|---|---|
|空|默认值，表示不是树形结构数据，将不组装\_\_nesting对象结构|
|0|表示不限制层数，由接口逻辑自行控制返回的数据层数|
|n|表示需要返回指定的n层数据|

  > 目前在实现上，n和0的含义都是一致的，都是由接口自行决定返回数据

### \_\_nesting 内置对象

新增一个专用于树形结构数据处理的出入参特有对象 `__nesting`

**作为入参** ：该结构在前端会由 `datarequest` 事件自动组装作为入参提交（需要配置了 `nestedlevel` 属性才会组装）

**作为出参** ：任何处理树形结构的接口，如查询，删除，编辑等等，都需要在返回的出参中增加 `__nesting` 用于指导前端属性结构数据的具体处理方式。

```json
{
  "__nesting": {
    "__focusednode": "",
    "__nestedlevel": "",
    "__operation": ""
  }
}
```

* \_\_focusednode

  当前请求的数据的焦点节点，该值会由树型数据控件传递到事件的临时上下文中。

  当该值为空表示当前请求数据从根节点开始

* \_\_nestedlevel

  当前请求的数据层数，通常只在作为入参时有用，该值直接填入 `datarequest` 事件的 `nestedlevel` 属性值。

* \_\_operation

  当前的数据操作类型，只在作为出参时填入，用于指导接收数据的控件做出对应的操作，提升数据变更是的UI更新体验，其取值如下

|取值|说明|
|---|---|
|load|默认值，加载，空值也代表加载，通常由datarequest事件返回|
|refresh|刷新|
|delete|删除|
|insert|插入|
|update|更新|
|order|排序|

* refresh

  将刷新 `__focusednode` 指节点下的数据，如果 `__focusednode` 为空表示刷新整棵树的数据

  > 实现上，先丢弃指定节点下的所有数据，再将新数据放入树中，保持树的当前展开状态。

* delete

  ```
  将删除返回数据中的对应节点，节点查找规则根据控件配置的树形数据结构
  ```

## 前端数据获取与设置

### 数据获取规则

* 支持范围获取

  树形数据依然支持常规的数据获取，包括配置和UIFlycode获取，但是不支持通过index来获取行数据，目前只支持通过 `focused`，`checked` 这两个范围值获取值，当获取 `focused` 数据时，获取到的将是一个对象，`checked` 获取到的是一个数组

* 树形结构支持焦点行上下文填充

  树形控件同样适用焦点行数据自动填充事件上下文的约定，即点击某一行时，该行数据会完整放入内存变量空间，供随后的事件获取。

  **特别的**：树形控件还会额外添加 `__focusednode` 作为焦点行的标记

* 列表型结构支持焦点行上下文填充

  当处在搜索条件下，树控件展示为列表样式，此时可以支持分页加载，其数据获取规则与普通列表一致，点击分页标签也会填充 \_\_pagging 相关数据。

### 数据设置规则

* 支持配置的方式设置数据

  包括datasubmit和datarequest两个行为的setter。

## 接口处理逻辑说明

这里对处理树形结构的行为做出统一的约定。

### 查询接口处理逻辑

```swift
if 有选中的节点 {
    return 查询(子节点).排序(叶子节点在前)
}
else if 没有搜索条件 {
    return 第一层节点
}
else {
    return 查询(搜索条件).排序(叶子节点在前).分页(分页信息)
}
```

![](http://apaas.wxchina.com:8881/wp-content/uploads/%E6%A0%91%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E6%90%9C%E7%B4%A2%E5%A4%84%E7%90%86.png)

### 数据提交接口返回数据约定

当没有搜索条件时，数据以树型结构展示，此时为了提升用户体验，在做如下操作，如删除，编辑，新增等，可以在接口的返回数据提供数据更新的具体信息。

* 插入

  可以新增多条数据，但必须是相同父节点

  ```swift
  return {
    "业务数据": ["数组结构"],
    "__nesting": {
      "__focusednode": "",    // 数据插入的节点
      "__operation": "insert" // 表示数据的处理方式
    }
  }
  ```

* 更新

  可以编辑多条数据，但不能改变树结构，例如根据勾选项启用或停用

  ```swift
  return {
    "业务数据": ["数组结构"],
    "__nesting": {
      "__focusednode": "",        // 无需指定节点，可以更新多个层级的节点数据
      "__operation": "update" // 表示数据的处理方式
    }
  }
  ```

* 删除

  可以删除多条数据，例如删除勾选项

  ```swift
  return {
    "业务数据": ["数组结构"],
    "__nesting": {
      "__focusednode": "",        // 无需指定节点，可以删除多个层级的节点数据
      "__operation": "delete" // 表示数据的处理方式
    }
  }
  ```

* 排序

  ```swift
  return {
    "业务数据": ["数组结构，可以编辑多条数据"],
    "__nesting": {
      "__focusednode": "",     // 排序节点的父级节点
      "__operation": "sort"  // 表示数据的处理方式
    }
  }
  ```

* 其他

  其他情况，如此时搜索条件不为空，或者有节点层级调整，或者处理的数据过多，或者处理的方式有多重等，统一按刷新处理，控件会自动调用刷新事件，重新获取数据

  ```swift
  return {
    "业务数据": [],                //此时不用返回业务数据
    "__nesting": {
      "__focusednode": "",            // 处理节点保持为空
      "__operation": "refresh"  // 数据刷新，控件将会主动触发刷新事件
    }
  }
  ```

### 跨表单数据刷新

如果树控件的数据是在其他表单修改的，此时只支持全部刷新的模式更新列表，即通过call event 事件，调用控件的onrefresh事件

## 控件接收数据处理规则

在接受到setter的数据后，根据不同的 `__operation` 值，控件将会作出不同的UI和数据响应

***以下操作，除了load外，其他都是在树型结构时的处理，如果是列表状态，都是直接调用onrefresh事件，同时传递出当前的pageindex信息，刷新当前页数据即可。***

### Load

该操通常是datarequest事件返回，此时控件需要根据 `__focusednode` 的值来判断具体加载哪个节点下的数据。

如果没有 `__nesting` 数据，则直接根据 `__paging` 数据按列表处理。

如果有 `__nesting` 数据，则做以下处理

**数据处理：**先丢弃指定节点下的所有数据，再将获取到的数据加入当前的树中。

**异常数据处理：**理论上返回的数据应该都是指定节点下的数据，但如果出现了其他节点下的数据，就直接丢弃。

**UI处理：**保持当前树结构的展开状态，自动填充焦点节点的下级节点数据。

### Refresh

遇到该操作就只是简单的触发控件的onrefresh事件，通常onrefresh内会配置加载数据的行为，之后的数据处理参看load

### Delete

**数据处理：** 根据返回数据的id，或者idpath，删除对应的节点以及其子节点数据

**异常数据处理：** 遇到在前端缓存中不存在的数据，就直接丢弃。

**UI处理：** 尽量保持当前树结构的展开状态，删除相关的节点。

### Insert

**数据处理：** 根据返回数据的pid，或者idpath，插入到对应的节点下

**异常数据处理：** 遇到在前端缓存中不存在的pid数据，就直接丢弃。

**UI处理：** 保持当前树结构的展开状态，在当前节点插入对应数据。

### Update

**数据处理：** 根据返回数据的id，或者idpath，更新对应节点数据

**异常数据处理：** 遇到在前端缓存中不存在的数据，就直接丢弃。

**UI处理：** 保持当前树结构的展开状态，更新对应节点数据。

### Order

**数据处理：** 直接更新焦点节点的下一级节点数据，可以丢弃这些节点的再下一级缓存的数据

**异常数据处理：** 返回的数据必须是在焦点节点下的数据，如果不是，丢弃。

**UI处理：** 保持当前树结构的展开状态，更新对应节点数据。