---
title: 表单数据缓存
date: 2020-05-19T19:36:23
---

# 表单数据缓存功能

表单数据缓存功能是指，用户在表单中输入数据时，自动存储输入的数据到缓存文件中，方便当用户意外退出表单后，可以重新找回已填写的数据。

## 缓存配置

### 主动配置

表单可以主动设置为支持缓存的相关信息，主动设置能够更精确的控制缓存。

```json
"pageinfo": {
    "code": "1061903577213177955",
    "cache": {
        "enable": "1",
        "keys": ["id"],
        "submitevents": ["1234123", "4564567567"]
    }
}
```

* enable

  是否允许缓存，bool 类型值，默认值为 1

* keys

  指定缓存表单需要的特殊标记，配置时从表单的入参中选择一个或多个入参，这些入参的 `value` 就作为标记的 `key` 放入该字段。

  表单引擎会使用这些字段的值的组合，作为 **业务值** 记录进 **表单实例标识** 中去。

* submitevents

  **提交事件**，用于指定表单中哪些事件是提交数据的事件。这些事件一旦执行成功，立即删除当前表单实例的缓存数据。

### 自动配置

如果表单没有设置 `cache` 字段，则使用自动配置方案。该方案会自动设置支持缓存的相关信息，具体如下

* enable

  搜索表单中是否存在数据上传行为 `datasubmit` ，如果有，则标记为 1， 否则标记为 0

* keys

  会将表单接收入参的事件 `receivelink` 的所有参数中，值为字符串的参数的作为 `key`

* submitevents

  所有包含 `datasubmit` 行为的事件，都会被标记为提交事件。

### 表单实例标识

即唯一标记一个缓存数据，只有当前表单的实例标识，与缓存数据的实例标识的值相同时，才认为该缓存数据为当前表单的数据。

实例标识是由多个值共同组成的，具体包括：`用户ID` + `企业ID` + `职位ID` + `表单ID` + `业务值1` + ... + `业务值N`

如果前端使用了不同的用户，企业，职位的数据的物理分离，则可以将缓存数据也使用相同的规则分割。这样的话实例标识就只剩下 `表单ID` + `业务值1` + ... + `业务值N`

## 规则说明

### 缓存

1. 用户在输入型控件中进行输入后立即缓存这个输入内容。

2. 当用户的点击会触发一个事件时立即缓存这个点击。

3. 对于文本输入框，数字输入框这类可以会使用键盘连续输入的控件，可以在关闭键盘，或者焦点离开该控件时触发缓存。

4. 缓存输入内容时，使用控件的code作为 **控件实例标识** ，如果是在数组型容器控件内部的控件，需要看该数组型控件是否配置了primarykey属性(primarykey的值可以设置为内存值的name或数组型控件内部控件的name)：

   1. 如果没有设置 primarykey，则需要使用 `容器控件code` + `indexPath` + `控件code` 作为缓存标识。

      其中 indexPath直接使用其section和row的值做标识，例如：容器A中，第0组第2行的控件B的实例标识为： `A/0/2/B`

   2. 如果设置了primarykey，则使用 `容器控件code` + `primarykey对应内存值或控件的值` + `控件code` 作为缓存标识。恢复时，只有找到了相同的primarykey的行的数据才会被恢复。

      * 注意：primarykey为控件的name

5. 缓存用户点击的时候，同样使用 **控件实例标识** 做为key，并缓存实际触发的事件的 trigger 。
6. 如果触发的 trigger 没有配置 handler，或者handler 对应的事件中有链接行为，则不缓存该 trigger。

##### 注意：

```
1. 缓存操作只缓存用户输入的值，不缓存自动获取的值(比如：定位等)
2. 对于没有在表单中设置enable字段，且没有配置提交事件(由于flycode编写的事件无法判断是否是提交事件，所以对于此判断来说，flycode编写的提交事件暂不算做提交事件)，代码中控制不进行缓存操作。没有提交事件的表单在表单中设置enable:"1"，也能开启缓存功能，但是不建议这么操作，因为无法清除缓存。
3. 当使用primarykey形式缓存时，primarykey对应内存值或控件的值需要唯一，不能相同，否则仍会出现缓存错乱的问题
```

### 恢复

1. 当表单执行完表单的onload事件，以及所有控件的onload事件后，使用当前表单的实例ID去缓存库中查询是否有缓存。
2. 如果有，则弹框提示用户是否使用缓存数据进行填充。
3. 当用户选择确定按钮后，取出缓存数据并填充进控件中。
4. 恢复操作根据缓存的顺序，依次进行恢复。
5. 当恢复输入内容时，自动触发对应控件的 onvaluechanged。
6. 当恢复用户点击时，自动触发对应的 trigger。
7. 当恢复时实际触发了事件，需要等待该事件执行完毕后，再执行下一个恢复。
8. 如果有数据找不到对应的控件，则丢弃。

### 清理

1. 当表单中的任一 **提交事件** 被成功执行后，即清理当前表单的缓存。
2. 当用户在恢复弹框时，选择了 **丢弃** 按钮后，清理当前表单的缓存。
3. 当用户使用清除缓存的功能时，清理所有的表单缓存。
4. 当缓存列表类控件，例如表格，内部的数据的时候，如果控件的数据被刷新（内存搜索除外）时，需要清除掉该控件的缓存。（PS. 实际中，这种情况应该不会存在，录入型的列表类控件，不应该配置数据刷新）
5. 当用户主动退出当前的表单时，需要检测当前表单是否有缓存数据，如果有，则提示用户是否保留缓存数据，如果用户选择了否，则清除当前的缓存数据

## 缓存时序

![](http://apaas.wxchina.com:8881/wp-content/uploads/CacheFlow.jpg)

## 缓存数据设计

各端可根据实际情况做出自己的设计，只要能满足缓存的需求即可。以下为一个简单的设计以供参考：

缓存数据由两部分组成：

1. 缓存文件目录。
2. 缓存文件

### 缓存文件目录

用于记录有缓存数据的表单文件的索引的目录文件，格式如下

|ID|path|update\_date|
|---|---|---|
|243213546123455\_456t34563\_2|243213546123455\_456t34563\_2.plist|18966532144|

如果缓存文件在一个文件夹里面，也可以不用真实存在一个目录文件，直接读取该文件夹的文件列表即可。

### 缓存文件

缓存文件里面实际记录了指定表单的缓存数据，其内部应该是一个字典，key为控件实例标识，value为缓存值：

|key|value|trigger|
|---|---|---|
|somebutton|nil|onclicked|
|sonetable\_0\_1\_sometextinput|A|onvaluechange|
|somedropdown|4|nil|

somebutton，只是点击事件，没有值  
  
sonetable\_0\_1\_sometextinput，即有输入，又有触发值改变事件  
  
somedropdown，有输入，但是没有值改变事件，或者值改变事件中有链接行为。