

flycode 是一种采用 javascript 语法，并可以结合 sql 语法进行数据查询的语言。

配置开发工程师，使用 flycode 仅需要编写业务相关逻辑。业务引擎会发布相应的服务接口，并自动处理多租户隔离、数据离线、数据追踪、数据权限、分页、排序等  平台逻辑。

flycode 除了可以使用 es5 标准 的 javascript 内置函数， 还提供了一些常用操作 API，如:日期，会话，输入输出上下文，数据库操作等；平台服务 API，如:excel 导入导出，发送消息等。

建议在编写 flycode 时，不要使用复杂的 js 技巧。flycode 代码尽量表达当前业务领域内的逻辑，以便于维护。

1.2. 何时需要 flycode
需要实现业务逻辑，并发布 rest 接口时，flycode。
需要实现业务逻辑，并发布重用函数时，flycode。
需要实现各种数据迁移（如导入导出 excel）时，flycode。
需要在逻辑中调用平台服务(如发送消息，流程处理)时，flycode。
1.3. flycode 如何运行
how.png

如上图所示:

业务操作

配置开发工程师 使用 配置 IDE 编写 flycode，将被存入 元数据引擎。
用户 登录 app 或 web 浏览器，app 或浏览器会调用 业务引擎 接口，业务引擎则会从元数据引擎获取 flycode 解析并运行，并返回结果。
任务调度

配置开发工程师 使用 配置 IDE 编写 flycode，并配置任务调度，将被存入 元数据引擎。
任务调度服务 达到触发条件时，触发请求接口，异步执行 flycode。

2. 第一行代码
   以下示例中，将演示 flycode 的重要特点 —— js 语法与 sql 语法相结合的数据查询操作，我们把这种语句称为 FlyQL(flycode 查询语言)。

示例场景说明：

假设  已经建立了业务对象 门店(kx_store)，并且有 ID(storeid)和 门店名称(storename)的属性。
编写业务逻辑: 获取 ID 为 1 的门店，将门店名称修改为“示例门店 1”，后保存。
js
// 查询门店表，获得 ID 为 1 的门店
var temp = SELECT storeid, storename FROM kx_store WHERE storeid = 1;

// 修改门店名称
temp[0].storename = '示例门店 1';

// 保存
DB.save(temp[0]);

3. 参考手册
   3.1. 核心库 API 检索
   3.1.1. BO 业务对象
   函数 说明
   BO.new() 实例化业务对象
   3.1.2. DB 数据库操作
   函数 说明
   DB.insert() 插入
   DB.update() 修改
   DB.delete() 删除
   DB.save() 保存
   DB.replace() 条件全表替换
   3.1.3. Date 日期
   函数 说明
   Date.parseDate() 时间戳-->Date
   new Date([时间字符串]) 时间字符串-->Date
   [Date 对象].Format() Date-->时间字符串
   [Date 对象].time() Date-->"yyyy-MM-dd HH:mm:ss"
   [Date 对象].date() Date-->"yyyy-MM-dd"
   [Date 对象].getDayBegin() 获取今日开始
   [Date 对象].getDayEnd() 获取今日结束
   [Date 对象].getLastDayBegin() 获取昨日开始
   [Date 对象].getLastDayEnd() 获取昨日结束
   [Date 对象].getWeekBegin() 获取本周开始
   [Date 对象].getWeekEnd() 获取本周结束
   [Date 对象].getMonthBegin() 获取本月开始
   [Date 对象].getMonthEnd() 获取本月结束
   [Date 对象].getLastMonthBegin() 获取上月开始
   [Date 对象].getLastMonthEnd() 获取上月结束
   [Date 对象].getYearBegin() 获取今年开始
   [Date 对象].getYearEnd() 获取今年结束
   [Date 对象].getLastYearBegin() 获取去年开始
   [Date 对象].getLastYearEnd() 获取去年结束
   [Date 对象].getQuarterBegin() 获取本季度开始
   [Date 对象].getQuarterEnd() 获取本季度结束
   3.1.4. FLY 工具库
   函数 说明
   FLY.log() 记录日志
   FLY.genId() 分布式 ID 生成
   FLY.nextval() 自增序列
   FLY.geocode() 中文地址转换成经纬度
   FLY.trimObjAttrValue() js 对象去除属性左右两端空格
   3.1.5. NOW 当前时间
   函数 说明
   NOW.time() 当前时间，精确到毫秒
   NOW.date() 当前时间，精确到天
   3.1.6. Number 数值转换
   函数 说明
   Number.toRoundDecimal 保留小数(四舍五入)
   Number.toFloorDecimal 保留小数(全部舍掉)
   3.1.7. SESSION 登录会话信息
   属性 说明
   SESSION.orgcode 组织编码
   SESSION.usercode 用户编码
   SESSION.pscode 岗位编码
   SESSION.mbcode 成员编码
   SESSION.accode 账号编码
   SESSION.ctcode 客户端类型编码(1-web 管理端、2-iPhone 端、3-Android)
   SESSION.rpscode 职位编码(模板岗位编码)
   SESSION.orgdim 组织维度 Id
   SESSION.codepath code 编码
   SESSION.isleaforg 判断当前登录人是否是组织架构叶子节点的
   3.1.8. String 字符串处理
   函数 说明
   String.substringLastAt 根据某字符截取字符串
   String.isBlank 判断字符串是否为空
   3.1.7. TX 事务控制
   函数 说明
   TX.begin() 开启事务
   TX.commit() 提交事务
   TX.rollback() 回滚事务
   3.2. 扩展库 API 检索
   3.2.1. ACCOUNT 平台账号模块
   函数 说明
   ACCOUNT.add() 新增账号
   ACCOUNT.enable() 启用账号
   ACCOUNT.disable() 停用账号
   3.2.2. CONFIG 系统配置
   函数 说明
   CONFIG.get() 获取指定 key 的系统配置 JSON
   3.2.3. MSG 消息模块
   函数 说明
   MSG.send() 发送消息
   3.2.4. PINYIN 拼音转换模块
   函数 说明
   PINYIN.get() 汉字转小写拼音
   PINYIN.getshort() 汉字转小写拼音简写
   3.2.5. WORKFLOW 工作流模块
   对象 说明
   WorkflowInfo 当前上下文中的流程信息
   函数 说明
   WORKFLOW.allocate() 流程发起
   WORKFLOW.submit() 流程提交
   WORKFLOW.terminal() 流程外部终止
   3.2.6. CACHE 缓存模块
   函数 说明
   CACHE.put() 添加
   CACHE.get() 获取
   CACHE.delete() 删除
   CACHE.increment() 增加
   3.2.7. OPENDATA 模块
   函数 说明
   OPENDATA.http() http 请求调用
   OPENDATA.query() 数据库查询
   OPENDATA.update() 数据库更新
   OPENDATA.ws() webservice 接口调用

3.1.1. 业务对象/输入/输出
3.1.1.1. 业务对象
在 flycode 里，业务对象为一种特殊的具有元信息的 js 对象结构。

从结构上看，分为单对象与对象数组
可使用 FlyQL 从数据库中查出
可使用 api 新实例 BO.new('业务对象名');
可使用 DB api 保存到数据库,具体详见数据库操作章节
API

js
// FlyQL 查出
var xx = SELECT p1, p2 FROM objectname;

// 使用 API 新实例
var xx = BO.new('<业务对象名>');Copy

例 1: 使用 FlyQL 查出业务对象，修改并保存

js
// 查询门店表，获得 ID 为 1 的门店。temp 就是具备原信息的 js 对象数据，即 flycode 中的业务对象数组
var temp = SELECT storeid, storename FROM kx_store WHERE storeid = 1;

// 修改门店名称
temp[0].storename = '示例门店 1';

// 保存
DB.save(temp[0]);Copy

例 2: 使用 api 实例化业务对象，赋值并保存

js
// 在 flycode 中新实例一个门店对象
var newStore = BO.new("kx_store");

newStore.storeid = FLY.genId();
newStore.storename = '示例门店 2';

// 保存
DB.save(new1);Copy

3.1.1.2. 输入输出
 业务逻辑定义的输入输出可以是业务对象，也可以是业务视图。

在业务逻辑运行时，输入数据会初始化并封装到 IN 对象中，flycode 中可通过 IN.对象名/视图名 进行引用。

例 1: 在输入中定义了业务对象 kx_store，从 IN 中获取业务对象，修改并保存

js
// 从入参中获取 kx_store 对象
var temp = IN.kx_store;

// 修改门店名称
temp.storename = temp.storename + "测试";

// 保存
DB.save(temp);Copy

例 2: 在输出中定义了业务对象 kx_store，查出数据，并赋给输出 OUT

js
// 查出门店数据
var temp = SELECT storeid, storename FROM kx_store;

// 赋给输出对象 OUT
OUT.kx_store = temp;Copy

3.1.1.3. 输入输出主从关系
输入输出可以有主从对象关联关系
主对象的属性为关联对象类型的，可关联出从业务对象及其属性
从业务对象的属性在输入输出中将被 拉平成二维结构，从对象的属性名将被别名为：主对象属性名*<上级主对象属性名\*\*>从对象属性名*。
例: 有门店和营销区域两个业务对象，门店中有一个所属营销区域的属性。输出门店，并关联其营销区域

业务对象结构如下：

json
// 门店
"kx_store": {
"storeid":"", //  门店 id
"storename":"", // 门店名称
"saleareaid":"" //所属营销区域
}

// 营销区域
"kx_salearea": {
"saleareaid":"", // 营销区域 id
"saleareaname":"" // 营销区域名称
}Copy

输出对象被拉平的结构如下：

json
"OUT":{
"kx_store":{
"storeid":"",
"storename":"",
"saleareaid":"",
"salreareaid\*\*saleareaname":"" // 从对象营销区域名称被拉平到主对象中
}
}Copy

js
// flycode 关联查询，sql 语句中，kx_salearea.saleareaname 需要根据出参的字段名做别名 as salreareaid\*\*saleareaname
var temp = SELECT kx_store.storeid, kx_store.storename, kx_store.saleareaid,
kx_salearea.saleareaname AS salreareaid\_\_saleareaname
FROM kx_store
LEFT JOIN kx_salearea ON kx_store.saleareaid = kx_salearea.saleareaid;

OUT.kx_store = temp;Copy

6
7
注:由于主从关系的字段名较长，不方便维护和编写 flycode，也可采用"为主对象添加自定义字段"的方法。如下

3.1.1.4. 自定义字段
输入输出对象，允许为已有对象添加自定义字段，将其转换为 DTO。
自定义字段不会自动绑定到业务对象的数据字段，需要编写 flycode 手动赋值。
例: 有门店和营销区域两个业务对象，门店中有一个所属营销区域的属性。输出门店，并将营销区域名称作为门店的自定义字段输出。

json
"OUT":{
"kx_store":{
"storeid":"",
"storename":"",
"saleareaid":"",
"saleareaname":"" // 该字段为自定义字段，可自己定义名称，比自动关联的字段要短得多，方便使用。
}
}Copy

查询的 flycode 如下:

js
// flycode 关联查询，saleareaname 赋值给了出参的 saleareaname
var temp = SELECT kx_store.storeid, kx_store.storename, kx_store.saleareaid, kx_salearea.saleareaname
FROM kx_store
LEFT JOIN kx_salearea ON kx_store.saleareaid = kx_salearea.saleareaid;

OUT.kx_store = temp;Copy

6
3.1.1.5. 内置入参
3.1.1.5.1. \_\_lazy 前端懒加载
未来版本预告，预计 2.5 版本上线:p

json
"IN":{
"\_\_lazy": {
"mode":"1",
"key":"当 mode 为 2,3 时，需要传值，只是为了方便查找",
"keypath":"当 mode 为 2, 3 时，需要传值，只是为了方便查找",
"level":"当 mode 为 2,3 时，需要传值，只是为了方便查找"
}
}Copy

由前端告知业务行为，是否采用懒加载:

mode:

值为：‘1’ ：取回所有第一级节点以及其对应二级节点，
值为：‘2’ ：取回当前传入节点的下一级节点
值为：‘3’ ：取回当前传入节点的下一级节点，当前 keypath 路径上所有祖先节点，当前节点的兄弟节点
flycode 示例：

js
if(IN.**lazy != null) {
if(IN.**lazy.mode == '1') {
//TODO 取回所有第一级节点以及其对应二级节点
} else if(IN.**lazy.mode == '2') {
//TODO 取回当前传入节点的下一级节点
} else if(IN.**lazy.mode == '3') {
//TODO 取回当前传入节点的下一级节点，当前 keypath 路径上所有祖先节点，当前节点的兄弟节点
}
}Copy

3.1.2.1. 查询基础
3.1.2.1.1. FlyQL 基础
以 "select" 开头(全大写或全小写)，";" 结尾的语句，被识别为 FlyQL。
FlyQL 的查询结果是一个 业务对象数组 或者 业务视图(如合并查询语句 union 等，无法被识别为业务对象的，将会以业务视图返回)，可赋给中间变量供后续处理，或直接赋给输出对象。
例: 查询门店信息，赋予 temp 变量

js
var temp = SELECT storeid, storename FROM kx_store;

OUT.kx_store = temp;

OUT.kx_store 的结构如下:

json
[
{
"storeid":"3242334",
"storename":"测试门店 1"
}
]

6
3.1.2.1.2. 关联查询 join
关联查询时，需要配置对应到输出对象属性的别名，输出对象中的关联对象规则详见 业务对象输入输出 章节

例: 查询门店信息，并关联出门店所属的营销区域名称

js
var temp = SELECT kx_store.storeid, kx_store.storename, kx_salearea.saleareaname as saleareaid\_\_saleareaname
FROM kx_store
LEFT JOIN kx_salearea ON kx_store.saleareaid = kx_salearea.saleareaid;

OUT.kx_store = temp;

OUT.kx_store 的结构如下:

json
[
{
"storeid":"3242334",
"storename":"测试门店 1",
"saleareaid__saleareaname":"测试区域 1" // 主对象字段 加两个下划线 加从对象字段
}
]

6
7
3.1.2.1.3. 合并查询 union
flycode 支持 union 等合并查询操作，合并查询的结果只能是业务视图，业务视图不能进行增删改。

例: 查询门店/渠道商信息，并合并

js
// 查询终端信息的 storeid,storename 合并 渠道信息的 channelid,channelname，合并后，字段名以第一个查询字段为准(此规则与 sql 标准相同)
var temp = SELECT storeid, storename
FROM kx_store
UNION
SELECT channelid, channelname
FROM kx_channel;

OUT.kx_store = temp;

输出结果:

json
"OUT":{
"kx_store":[
{
"storeid":"",
"storename":"门店 1"
},
{
"storeid":"",
"storename":"渠道 1"
},
...
]
}

3.1.2.2. FlyQL 模板语法
在 sql 查询语句中可以穿插动态模板 {js 语句}，运行时根据模板条件组装语句，实现动态 SQL。

API

js
// 动态参数引用: { }
// 动态条件语句: {#if } {#endif}
1
2
例 1: 查询门店信息，查询条件门店名称来自输入参数

js
// 假设输入参数 kx_store.storename 为前端输入的门店名称
// IN 为输入对象的集合，可参考 业务对象/输入/输出 章节
var temp = SELECT storeid, storename FROM kx_store
WHERE storename = {IN.kx_store.storename};

4
例 2: 查询当前登录人所负责的门店

js
// SESSION.mbcode 为当前登录人成员编号
// 门店列表查询过滤出当前责任人等于当前登录人的记录
var temp = SELECT storeid, storename FROM kx_store
WHERE princial = {SESSION.mbcode};

4
例 3: 根据入参是否存在动态拼接语句

js
// 若 IN.kx_store.storename 不为空，则加入条件语句
var temp = SELECT storeid, storename FROM kx_store
{#if IN.kx_store.storename != null}
WHERE storename = {IN.kx_store.storename}
{#endif}

3.1.2.3. 标记语法
3.1.2.3.1. 分页标记
则会根据前端提供的分页信息，自动组装分页相关的 sql 语句。

API

js
// 在 flyQL 语句结尾加上 paging 或 PAGING 的标记，则引擎会自动对结果进行分页,并统计数据总条数
var temp = SELECT xx FROM xxx paging;
1
2
例子: 查询门店信息，并分页

js
var temp = SELECT storeid, storename FROM kx_store PAGING;
OUT.kx_store = temp;
1
2
输出结果：

json
"OUT": {
"kx_store":[
{
"storeid":"",
"storename":""
}
...//5 条记录
],
"**paging":{ // 有分页时，输出会增加一个内置对象**paging
"**pageindex":"0", // 第 1 页
"**pagesize":"5", // 每页条数
"\_\_itemcount":"105" // 数据总条数
}
}

13
14
由于平台根据已有 sql 自动统计数据总条数，在某些场景中可能影响性能，用户可自定义统计条数的 sql 语句

例子: 查询门店信息，并分页，数据总条数设置

js
// 自定义统计条数的 sql 语句
var cc = SELECT count(1) as c FROM kx_store;
var itemcount = cc[0].c;

// PAGING 后加上数据总数变量，平台则会使用以上统计结果
var temp = SELECT storeid, storename FROM kx_store PAGING(itemcount);

OUT.kx_store = temp;

输出结果：

json
"OUT": {
"kx_store":[
{
"storeid":"",
"storename":""
}
...//5 条记录
],
"**paging":{ // 有分页时，输出会增加一个内置对象**paging
"**pageindex":"0", // 第 1 页
"**pagesize":"5", // 每页条数
"\_\_itemcount":"105" // 数据总条数
}
}

13
14
3.1.2.3.2. 动态排序标记
该标记会根据前端提供的动态排序信息，自动组装动态排序相关的 sql 语句。
该标记生成的排序与 SQL 语句中的 order by 互相叠加
前端提供的动态排序信息，与入参对象平行一起传递:

json
{
"kx_store":{ // 业务对象
"storename":""
},
"\_\_sorting":[ // 前端提供的动态排序信息
{
"key":"排序的字段名",
"type":"asc 或 desc"
},
...
]
}

API

js
// 在 flyQL 语句结尾加上 sorting 或 SORTING 的标记，则引擎会自动对结果进行排序
var temp = SELECT xx FROM xxx sorting;
1
2
例: 查询门店信息，当用户在表格控件上点击 storename 的列头时，动态切换排序语句

js
var temp = SELECT storeid, storename FROM kx_store order by storeid desc SORTING;
OUT.kx_store = temp;
1
2
sql
-- 1. 默认返回的列表按照 storeid 降序排列
-- 2. 当用户单击表格控件上的 storename 列头，切换为 storeid 降序和 storename 升序排列，
-- flycode 引擎遇到 SORTING 标记 后，则会生成如下 sql 语句去执行
SELECT storeid, storename FROM kx_store order by storeid desc, storename asc

4
sql
-- 当用户再次单击表格控件上的 storename 列头，切换为 storename 降序排列
-- flycode 引擎遇到 SORTING 标记 后，则会生成如下 sql 语句去执行
SELECT storeid, storename FROM kx_store order by storeid desc, storename desc

输出结果：

经过排序后的结果

提示：分页和排序标记仅仅是一个标记，可以同时使用，且不分前后顺序；如:句末加 paging sorting 同等于 sorting paging;

3.1.2.3.3. 数据权限标记
该标记是控制数据权限的，会根据该标记动态拼装过滤 SQL，达到权限控制的效果

数据权限标记置于 SQL 的最后（与分页、排序同等，不分先后顺序）

数据权限标记分 4 种情况：

不使用权限标记，则该 SQL 默认所有相关业务实体都检查权限

标记“NORULE”，则该 SQL 的所有相关业务实体都不检查权限

标记白名单“RULE(["A","B"])”,则该 SQL 只对 A 和 B 业务主数据进行权限控制（注意：当使用白名单，字典实体默认存在白名单中）

标记黑名单“NORULE(["A","B"])”,则该 SQL 会忽略 A 和 B 业务主数据的权限控制

例子：终端实体(kx_store)关联了营销区域(pl_salearea)，其中营销区域为主数据，登录的岗位绑定了只能看本营销区域的数据的权限规则

sql
--1.原始 SQL
select _ from kx_store NORULE; 等同于 select _ from kx_store NORULE(["pl_salearea"]);
--转化后 SQL
select \* from kx_store;

    --2.原始SQL
    select * from kx_store; 等同于 select * from kx_store RULE(["pl_salearea"]);
    --转化后SQL
    select kx_store.* from kx_store kx_store
    left join pl_salearea pl_salearea on kx_store.saleareaid = pl_salearea.orgstructid
    where pl_salearea.codepath = '123456789';

9
10
11
3.1.2.3.4. 平台字段标记(NOPLAT)
平台业务对象对应的数据库表, 总是包含几个平台内置的字段.

platcreatetime: 数据的创建时间

platupdatetime: 数据的更新时间

platcreateop: 数据创建的操作人的成员 id

platupdateop: 数据创建的更新人的成员 id

platstatus: 数据状态 1: 正常 2: 逻辑删除了

NOPLAT 标记会忽略 platstatus 条件 ，一般使用在离线下载的逻辑上

不使用此标记时, 所有的查询默认不会将[逻辑删除]状态的数据查询出来.

NOPLAT 标记写在 SQL 的最后（与分页、排序同等，不分先后顺序）

例子

sql
--原始 SQL
select _ from kx_store a
left join pl_salearea b on a.salesareaid = b.id
where a.id = '1111' NOPLAT;
--转换后的 SQL
select _ from kx_store a
left join pl_salearea b on a.salesareaid = b.id
where a.id = '1111';
--假如不加 NOPLAT 的转化 SQL：
select \* from kx_store a
left join pl_salearea b on a.salesareaid = b.id and b.platstatus = 1
where a.id = '1111' and a.platstatus = 1;

3.1.3. 库引用
3.1.3.1. 扩展库
3.1.3.2. 自定义模块
在配置 IDE 中，有一种业务逻辑类型为自定义模块，一个业务逻辑可定义一个模块，也可只包含一个 function。

API

js
// 自定义模块引用
loadex("模块名");
1
2
例子: 定义了一个数学库，包含加减法。引用并使用库函数。

js
// 模块声明方法与 js 声明方法相同，如定义了一个名为 MathEx 模块，模块声明代码如下：
var add = function(a, b) {
return a+b;
};

var sub = function(a, b) {
return a - b;
};

js
// 如引用上例中的模块 MathEx
loadex("MathEx");

// 即可使用该模块
print(MathEx.add(1, 2));
print(MathEx.sub(1, 2));

3.1.4. 异常及提示
3.1.4.1. 抛出异常
API

js
throw new ERROR("异常信息");
1
例子: obj 为空时抛出异常

js
if(obj == null){
throw new ERROR("出现异常！");
}

出参:

json
{
"error_type": 600,
"error_code": "出现异常！",
"error_params": null
}

3.1.4.2. 返回提示信息
API

js
// info 和 warn 的用法一样，只是提示的等级不一样
FLY.info(<提示信息>);
FLY.info(<提示信息>,<信息对象>);
FLY.warn(<警告信息>);
FLY.warn(<警告信息>,<信息对象>);

例子 1：直接给前端提示消息

js
FLY.warn("操作有误，请重新操作！");
1
出参：

json
{
"resp_data": {
"<出参对象>": {},
"\_\_dataprocessresult": [
{
"message": "操作有误，请重新操作！",
"params": {},
"type": "warning"
}
]
}
}

例子 2:使用占位符的方式（括号前的\不能省略）

js
var a = {};
a.totalcount = 7;
a.successcount = 5;
a.errorcount = 3;
FLY.info("总共\(totalcount)条，成功\(successcount)条，失败\(errorcount)条",a);

出参：

json
{
"resp_data": {
"<出参对象>": {},
"\_\_dataprocessresult": [
{
"message": "总共\(totalcount)条，成功\(successcount)条，失败\(errorcount)条",
"params": {
"totalcount": "7",
"successcount": "5",
"errorcount": "3"
},
"type": "info"
}
]
}
}

3.1. 核心库
核心库包含动态引擎自带的库函数及模块，无需引用可直接使用。包含：

数据库操作 DB TX
登录会话信息 SESSION
日期时间 NOW Date
工具库 FLY

3.1.2. 登录会话信息
SESSION 对象为 flycode 内置对象，可获取到当前登录人的一些信息。

API

js
SESSION.orgcode; // 组织编码

SESSION.usercode; // 用户编码

SESSION.pscode; // 岗位编码

SESSION.mbcode; // 成员编码

SESSION.accode; // 账号编码

SESSION.ctcode; // 客户端类型编码(1-web 管理端、2-iPhone 端、3-Android)

SESSION.rpscode; // 职位编码(模板岗位编码)

SESSION.orgdim; // 组织维度 Id

SESSION.codepath; // code 编码

SESSION.isleaforg; // 判断当前登录人是否是组织架构叶子节点的

SESSION.appcode; // 当前应用编码 (sales, distribution, promotion)

SESSION.appcodes : List<String>; // 当前用户可用应用编码

SESSION.categorycode; // 岗位类别

SESSION.subpdcodes; // 子产品编码

25
26
27
js

以下内容由颜潮盛 整理（202203）

--------------web 端
SESSION 对象为 flycode 内置对象，可获取到当前登录⼈的⼀些信息。
SESSION.orgcode;               //  组织编码
SESSION.usercode;             //  ⽤户编码
SESSION.pscode;                 //  岗位编码
SESSION.mbcode;                 //  成员编码
SESSION.accode;                 //  账号编码
SESSION.ctcode;                 //  客户端类型编码(1-web 管理端、2-iPhone 端、3-Android)
SESSION.rpscode;               //  职位编码(模板岗位编码)
SESSION.orgdim;                 //  组织维度 Id
SESSION.codepath;             // code 编码
SESSION.isleaforg;           //  判断当前登录⼈是否是组织架构叶⼦节点的
SESSION.appcode;         //  当前应⽤编码(sales,distribution, promotion)
SESSION.appcodes : List<String>;       //  当前⽤户可⽤应⽤编码
SESSION.categorycode;      //  岗位类别
SESSION.subpdcodes;         //  ⼦产品编码

----------------------app 端
System
1. System.user() //获取用户信息
System.user().accountCode  //账号编码
System.user().userinfoName //用户名称
System.user().userinfoID //用户 id
System.user().tenantName //企业名称  
System.user().tenantCode //企业编码
System.user().orgName //组织名称
System.user().orgCode //组织编码
System.user().positionID //
System.user().positionName //
System.user().mbCode //  成员编码
System.user().refpositionID //职位编码
System.user().appCode //当前登录的应⽤编码
System.user().appCodes //当前租户的应⽤列表
System.user().categoryCode //当前的职位类别
System.user().subpdCodes //当前租户⼦产品列表
2. System.context() //获取当前用户登录信息
System.context().isOffline //当前是否离线
System.context().token //当前⽤户登录的 token
System.context().httpAddress // http 请求 url 头
System.context().versionName //版本名称
System.context().versionCode //版本号
3. System.uniqueid() //获取⼀个的 uniqueid
4. System.date() //获取服务端当前时间
5. System.functionCodes() //获取功能权限
6. System.functionCheck(['80998877734324']) //功能权限检测
7. System.consloe('request  is OK') //控制⽇志输出

3.1.3. 数据库操作
3.1.3.1. 增删改
DB api 提供对业务对象的增删改，并支持批量处理功能，允许操作对象数组。
提供单对象的 save，自动根据对象是否存在，做插入/更新逻辑。
API

js
// 添加业务对象到业务数据库，如果业务对象类型为数组，则会批量操作
DB.insert(业务对象/数组);

// 更新业务对象到业务数据库，如果业务对象类型为数组，则会批量操作
DB.update(业务对象/数组);

// 根据传入的字段作为条件更新业务对象，如果业务对象类型为数组，则会批量操作，使用“:”分割加入时间格式表达式来格式化时间条件字段
DB.update(业务对象/数组,"业务对象.字段 A","业务对象.字段 B:yyyy-MM-dd",...);

// 根据业务对象的 ID，从业务数据库中移除数据(逻辑删除)，如果业务对象类型为数组，则会批量操作
DB.delete(业务对象/数组);

// 根据 ID 唯一性规则自动识别业务对象的新增和更新到业务数据库，不做批量处理(由于 save 的内部机制是需要查询后判断插入还是更新，若做批量可能影响性能，将批量交由外部处理)
DB.save(业务对象);

// 根据传入的业务对象字段识别对业务对象进行插入还是更新操作，使用“:”分割加入时间格式表达式来格式化时间条件字段
DB.save(业务对象,"业务对象.字段 A","业务对象.字段 B:yyyy-MM-dd",...);

// 根据删除条件对象去进行物理删除，然后插入业务对象/数组（该操作是物理删除，建议只使用在关联表上）
DB.replace(业务对象/数组,删除条件对象);

// 根据传入的业务对象去寻找依赖它的对象，返回值 {"result":布尔值,"refBy":"对象英文名","refName":"对象中文名"}
DB.findObjectRef(业务对象);

13
14
15
16
17
18
19
20
21
22
23
例 1: 新建名为"测试门店 1"的门店，并插入数据

js
// 实例化一个门店业务对象
var store = BO.new('kx_store');

store.storeid = FLY.genId();
store.storename = '测试门店 1';

// 插入门店
DB.insert(store);

例 2: 查出门店对象数组，遍历修改状态，后更新。

js
// 查出门店对象数组
var storeList = SELECT storeid, storename, status FROM kx_store;

// 遍历修改状态
for(var i = 0; i < storeList.length; i++) {
storeList[i].status = '1';
}

// 批量更新数组
DB.update(storeList);

9
10
例 3: 寻找关联产品的对象。（订单明细依赖产品）

js
// 创建产品对象
var product = BO.new("kx_kq_product");
product.id = '1';
// 寻找被依赖信息（返回找到的第一个）
var result = DB.findObjectRef(product);//{result=true, refBy=kx_order_detail,refName=订单详情表}
FLY.log(result.result);//true
FLY.log(result.refBy);//kx_order_detail
FLY.log(result.refName);//订单详情表

3.1.3.2. 事务控制
flycode 操作默认没有事务事务，需要开发人员手动控制事务；

API

js
TX.begin(); // 开启事务
TX.commit(); // 提交事务
TX.rollback(); // 回滚事务（可以不写，出现异常平台会自动回滚事务）

例子

js
var temp = select id,name,status
from kx_store
where id = 1;
temp[0].name = "华润万家";

TX.begin(); // 开启事务

//新增一条记录
DB.insert(temp[0]);
// 改名
temp[0].name = "沃永润";
DB.update(temp[0]);

TX.commit(); // 提交事务

3.1.4. 日期时间
3.1.4.1. 当前日期
API

js
// 获取当前时间字符串(返回 UTC 时区的时间字符串)
NOW.time(); // 当前时间，精确到毫秒 yyyy-MM-dd HH:mm:ss.fff
NOW.date(); // 当前时间，精确到天 yyyy-MM-dd

3.1.4.2. 日期格式化
API

js
// 日期格式化
var datestr = [Date 对象].Format(""); // 参数：表达式 yyyy-MM-dd HH:mm:ss
1
2
例: 返回当前的 月 日 时 分

js
var date = new Date();
var ret = date.Format("MM dd HH mm");

// 若当前时间为 2017-08-24 11:40:28，则 ret 为"08 24 11 40"

4
3.1.4.3. 日期常用 API
API

时间的转换

时间戳 --> Date ： Date.parseDate([时间戳]);

Date --> 时间戳 ：[Date 对象].getTime();

时间字符串 --> Date：new Date([时间字符串]);

Date --> 时间字符串 ：[Date 对象].Format([时间格式,如：yyyy-MM-dd HH:mm:ss]);

[Date 对象].time(); -- 获取时间格式为“yyyy-MM-dd HH:mm:ss”的时间

[Date 对象].date(); -- 获取时间格式为“yyyy-MM-dd”的时间

时间段的获取

今日：[Date 对象].getDayBegin(); /[Date 对象].getDayEnd();

昨日：[Date 对象].getLastDayBegin(); / [Date 对象].getLastDayEnd();

本周：[Date 对象].getWeekBegin(); / [Date 对象].getWeekEnd();

上周：[Date 对象].getLastWeekBegin(); / [Date 对象].getLastWeekEnd;

本月：[Date 对象].getMonthBegin(); / [Date 对象].getMonthEnd();

上月：[Date 对象].getLastMonthBegin(); / [Date 对象].getLastMonthEnd();

今年：[Date 对象].getYearBegin(); / [Date 对象].getYearEnd();

上年：[Date 对象].getLastYearBegin(); / [Date 对象].getLastYearEnd();

本季度：[Date 对象].getQuarterBegin();/[Date 对象].getQuarterEnd();

例:获取某个时间的当天开始时间、结束时间

js
var dt = new Date('2018-01-01 12:12:12');
FLY.log(dt.getDayBegin());//2018-01-01 00:00:00
FLY.log(dt.getDayEnd());//2018-01-01 23:59:59

3.1.5. 工具库
3.1.5.1. 打印日志
打印日志仅用于 IDE 调试 flycode 使用，可在 IDE 输出调试日志。

API

js
FLY.log('<日志信息>');
1
3.1.5.2. 分布式 ID 生成
业务对象的 ID 为全局唯一 ID，所有新建的业务对象的 ID，都应该使用该 API 生成。

API

js
FLY.genId();
1
目前的平台实现，将会返回全局唯一的长整形的数

例: 新建一个门店对象，并为其生成唯一 ID

js
var store = BO.new('kx_store');

store.storeid = FLY.genId();
store.storename = '测试门店 1';

4
store.storeid 的值为 "4327984237498327" 长整形的数

3.1.5.3. 自增序列
有些业务编码，需要为其创建自增序列，使用该 API 生成，每个自增序列必须有一个全局唯一 KEY。

API

js
FLY.nextval('<自增 key>');
1
nextval 将会在<自增 key>上下文中取到自增序列最后的值

例:  假设门店编号规则为"MD" 前缀 + 4 位自增的数字

js
// 使用 STORE_MD 作为自增序列的 key
var storeid = 'MD' + ( "0000" + FLY.nextval('STORE_MD') ).substr( -4 );
1
2
storeid 将为:
MD0001
MD0002
MD0003
...

3.1.5.4. 地址转经纬度（高德地图）
注意：此接口已被废弃,如需地图相关服务，请参考拓展库：高德地图服务

可以把地址，比如“广州市天河区维多利亚广场” 转换成经纬度（高德地图）。

API

js
FLY.geocode('<地址>');
1
例:

js
var addressObj = FLY.geocode("广州市天河区维多利亚广场");
FLY.log(addressObj.state); //状态： success：成功， failure：失败
FLY.log(addressObj.des); //结果描述
FLY.log(addressObj.location); //经纬度，比如"116.484546,39.990064"，逗号左边是经度，右边是纬度

4
3.1.5.4. js 对象去除属性左右两端空格
API

js
FLY.trimObjAttrValue('待去除属性左右空格的 js 对象');
1
例:

js
var obj = {"key": " value "};
FLY.log(obj.key); //此时打印“ value ”
obj = FLY.trimObjAttrValue(obj);
FLY.log(obj.key); //此时打印“value”

4
3.1.5.5. 字符串处理
根据某字符截取字符串：String.substringLastAt(<字符串>,<分隔符>,<从后面第几个开始截>);
例子

js
var str = '玄武集团/华南大区/广州分公司/销售一部';
var newstr = String.substringLastAt(str,'/',3);
FLY.log(newstr); // 华南大区/广州分公司/销售一部

判断字符串是否为空:String.isBlank(<字符串>); //不会去掉空格
例子

js
FLY.log(String.isBlank('')); // true
FLY.log(String.isBlank(' ')); // false
.1.5.6. 数值转换
保留小数(四舍五入)：Number.toRoundDecimal(<数值>,<保留几位>);
保留小数(全部舍掉)：Number.toFloorDecimal(<数值>,<保留几位>);
例子

js
FLY.log(Number.toRoundDecimal(2.3456,2));//2.35
FLY.log(Number.toRoundDecimal(2.3446,2));//2.34
FLY.log(Number.toFloorDecimal(2.3456,2));//2.34
FLY.log(Number.toFloorDecimal(2.3446,2));//2.34

4
3.1.5.7. 字典 Key 查询
根据字典编码获取字典 Key：DIC.getDicKeyByCode(<对象名称>,<字典编码>);
例子

js
var Cost = {};
Const.ordertype_unhandle = DIC.getDicKeyByCode("ordertype","001"); // 未处理
Const.ordertype_handled = DIC.getDicKeyByCode("ordertype","002"); // 已处理

    if(IN.kx_order.type == Const.ordertype_unhandle){
            // TODO
    }else if(IN.kx_order.type == Const.ordertype_handled){
            // TODO
    }

9
3.1.5.8. 记录操作日志
记录用户操作行为日志：LOG.recordLog(<模块名称>,<操作类型>,<操作日志>);
例子

js
LOG.recordLog("人员管理", "新增", "人员新增: "+IN.pl_userinfo.userinfoname);

3.1.6. 原生 SQL 操作
最低版本要求：动态业务服务 V2.8.0

3.1.6.1. 目的
SQL api 提供对数据库语句操作，支持原生查询、插入、更新、删除等操作，并支持调用存储过程。
API

js
//参数定义 params
var params = {"key1": "value1", "key2": "value2"};

//原生 sql 查询 返回 List 数据 [{"column":"value"}]
//可支持存储过程调用
var listResult = SQL.query(sql, params);

//原生 sql 查询 返回单字符串数据 "value"
var strResult = SQL.queryForString(sql, params);

//原生 sql 查询 返回 map 数据 {"key":"value"}
var mapResult = SQL.queryForMap(sql,params);

//原生 sql 返回被修改的行数
var intResult = SQL.update(sql, params);

//原生 sql 返回被修改的行数数组
var intResults = SQL.batchUpdate(sql, batchParams);

//原生查询，数据规则语句获取
var ruleobj = "kx_kq_store";
//数据查询语句，用到的数据对象的对象名、表名、别名
var rule_objmaps = [
{
"objectmark": "kx_kq_store",
"tablename": "kx_kq_store",
"alias": "kx_kq_store"
}
];
var rule_extraparam = {};
//返回 rule_res = {"join_sql": "", "where_sql":"", "rule_param":{}}
var rule_res = SQL.getRuleSql(ruleobj,rule_objmaps,rule_extraparam);

25
26
27
28
29
30
31
32
3.1.6.2 例子
例子用到的数据表
sql
CREATE TABLE "public"."test_simpletable" (
"platcreatetime" timestamp(0) DEFAULT ('now'::text)::timestamp(0) with time zone,
"platupdatetime" timestamp(0) DEFAULT ('now'::text)::timestamp(0) with time zone,
"platcreateop" int8,
"platupdateop" int8,
"platstatus" int4 DEFAULT 1,
"simplecode" int8 NOT NULL,
"simplename" varchar(200) COLLATE "default",
"simplememo" varchar(200) COLLATE "default",
CONSTRAINT "pk_test_simpletable_1" PRIMARY KEY ("simplecode")
)
WITH (OIDS=FALSE)
;

ALTER TABLE "public"."test_simpletable" OWNER TO "postgres";

COMMENT ON COLUMN "public"."test_simpletable"."platcreatetime" IS '平台固定字段，记录创建时间';

COMMENT ON COLUMN "public"."test_simpletable"."platupdatetime" IS '平台固定字段，记录修改时间';

COMMENT ON COLUMN "public"."test_simpletable"."platcreateop" IS '平台固定字段，创建人 id';

COMMENT ON COLUMN "public"."test_simpletable"."platupdateop" IS '平台固定字段，修改人 id';

COMMENT ON COLUMN "public"."test_simpletable"."platstatus" IS '平台固定字段，记录状态 1. 正常 2. 逻辑删除 3. 异常数据';

COMMENT ON COLUMN "public"."test_simpletable"."simplecode" IS 'simplecode';

COMMENT ON COLUMN "public"."test_simpletable"."simplename" IS 'simplename';

COMMENT ON COLUMN "public"."test_simpletable"."simplememo" IS 'simplememo';

25
26
27
28
29
30
31
例 1: 原生查询

查询终端，以编码和名称作为入参，匹配查询。并且分页查询

用到 API
var tmp = SQL.query(sql,params);
查询返回列表
var countres = SQL.queryForString(sql,params);
查询返回数量
注意点
分页参数，需要自行组装
分页语句，也是自行组装
flycode
js
/_
原生语句查询
_/

//入参参数
var \_inparam = IN.kx_kq_store;

//分页参数
var \_pagingParam = IN.**paging;
var \_pagesize = 20;
var \_offset = 0;
if(!!\_pagingParam) {
\_pagesize = \_pagingParam.**pagesize;
var pageindex = \_pagingParam.\_\_pageindex;
\_offset = (pageindex == 1 || pageindex == 0) ? 0 : (pageindex \* \_pagesize);
}

//查询参数定义
var params = {
"storecode": \_inparam.storecode,
"storname": \_inparam.storename,
"pagesize": \_pagesize,
"offset": \_offset
};

var \_sqlBuilder = [];
var \_countSqlBuilder = [];

_sqlBuilder.push("select id, storecode, storename from kx_kq_store where 1=1 ");
\_countSqlBuilder.push("select count(\*) from kx_kq_store where 1=1 ");
if(!!\_inparam.storecode) {
\_sqlBuilder.push(" and storecode like CONCAT(CONCAT('%',REPLACE(REPLACE(:storecode, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
\_countSqlBuilder.push(" and storecode like CONCAT(CONCAT('%',REPLACE(REPLACE(:storecode, '%', '/%'), '_', '/\_')), '%') ESCAPE '/' ");
}

if(!!_inparam.sotrename) {
\_sqlBuilder.push(" and storename like CONCAT(CONCAT('%',REPLACE(REPLACE(:storename, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
\_countSqlBuilder.push(" and storename like CONCAT(CONCAT('%',REPLACE(REPLACE(:storename, '%', '/%'), '_', '/\_')), '%') ESCAPE '/' ");
}

\_sqlBuilder.push(" order by updatetime desc ");

//分页
if(!!\_pagingParam) {
\_sqlBuilder.push(" limit :pagesize offset :offset ");
}

var \_sql = \_sqlBuilder.join("");
var \_countsql = \_countSqlBuilder.join("");

var tmp = SQL.query(\_sql, params);
var countres = SQL.queryForString(\_countsql, params);

OUT.kx_kq_store = tmp;

//输出分页
if(!!\_pagingParam) {
OUT.**paging = {"**pageindex": \_pagingParam.**pageindex, "**pagesize": \_pagingParam.**pagesize, "**itemcount": countres};
}

例 2: 执行操作

insert update delete 等操作

使用场景
更新或删除符合条件的数据
一个数据写入、更新、删除
用到 API
SQL.update(sql, params);

flycode 例子
js

var res = SQL.update(
"update test_simpletable set simplename=:name where simplename=:qname",
{
'name':'test3',
'qname':'test1'
}
);

FLY.log('影响的行数:' + res);

9
10
例 3: 批量操作

用到 API
SQL.batchUpdate(sql, paramsArray);
可用到场景
批量执行语句，传入的是一个数组数据。包括 insert\update\delete
flycode 例子
js

var res = SQL.batchUpdate(
"insert into test_simpletable (simplecode,simplename,simplememo) values(:code, :name, :name)",
[{
'code':FLY.genId(),
'name':'test1'
},
{
'code':FLY.genId(),
'name':'test2'
}
]);

例 4: 存储过程

执行插入或更新存储过程，无返回值

存储过程例子
sql

create or replace Function myfuncupdateorinsertdatanoreturn(simplecodep int8, simplenamep varchar, simplememop varchar) returns void as $$
declare --变量声明
msgtip varchar;
sql varchar;
begin

msgtip := '';

begin
if exists (select 1 from test_simpletable where simplecode = simplecodep) then
--更新
UPDATE test_simpletable
SET simplename=simplenamep, simplememo=simplememop,
platupdatetime=now()
WHERE simplecode = simplecodep;
else
--插入
INSERT INTO test_simpletable(
simplecode, simplename, simplememo)
VALUES (simplecodep, simplenamep, simplememop);
end if;

exception
when others then
msgtip := '出现错误';
end;

end;

$$
language plpgsql;




25
26
27
28
29
30
用到API
SQL.query(sql, params);
注意点
存储过程中，异常捕捉问题？
由于该种写法，是无返回的处理，建议少用
flycode
js
/*
调用存储过程 无返回
*/

var _inparam = IN.test_simpletable;

var params = {
  "simplecodep": _inparam.simplecode,
  "simplenamep":_inparam.simplename,
  "simplememop": _inparam.simplememo
};

var _sql = "select * from myfuncupdateorinsertdatanoreturn(:simplecodep,:simplenamep,:simplememop)";

var res = SQL.query(_sql, params);



13
14
15
例子5 原生查询 规则语句API使用

查询终端数据，用了终端对象数据规则
js
/**
规则语句API使用例子
*/
//入参参数
var _inparam = IN.kx_kq_store;

//分页参数
var _pagingParam = IN.__paging;
var _pagesize = 20;
var _offset = 0;
if(!!_pagingParam) {
  _pagesize = _pagingParam.__pagesize;
  var pageindex = _pagingParam.__pageindex;
  _offset = (pageindex == 1 || pageindex == 0) ? 0 :  (pageindex * _pagesize);
}

var params = {
  "storecode": _inparam.storecode,
  "storname": _inparam.storename,
  "pagesize": _pagesize,
  "offset": _offset
};

//规则语句， 原生查询语句中用到的对象数据表及别名
var rule_objmaps = [
  {
    "objectmark": "kx_kq_store",
    "tablename": "kx_kq_store",
    "alias": "kx_kq_store"
  }
];
var rule_extraparam = {};

//原生查询，数据规则语句获取
var rule_res = SQL.getRuleSql("kx_kq_store",rule_objmaps,rule_extraparam);
//返回规则语句的结果
FLY.log("join_sql===="+rule_res.join_sql);
FLY.log("where_sql===="+rule_res.where_sql);
FLY.log("rule_param===="+rule_res.rule_param);

//合并规则语句中的参数
if(rule_res != null && rule_res.rule_param != null) {
  for (var key in rule_res.rule_param) {
    params[key] = rule_res.rule_param[key];
  }
  //利用java的Map putAll方法
  //rule_res.rule_param.putAll(params);
  //params = rule_res.rule_param;
}

var _sqlBuilder = [];
var _countSqlBuilder = [];

//SQL语句组装
_sqlBuilder.push("select id, storecode, storename  from kx_kq_store ");
_sqlBuilder.push(rule_res.join_sql);
_sqlBuilder.push(" where 1=1 ");
_countSqlBuilder.push("select count(*) from kx_kq_store ");
_countSqlBuilder.push(rule_res.join_sql);
_countSqlBuilder.push(" where 1=1 ");
if(!!_inparam.storecode) {
  _sqlBuilder.push(" and storecode like CONCAT(CONCAT('%',REPLACE(REPLACE(:storecode, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
  _countSqlBuilder.push(" and storecode like CONCAT(CONCAT('%',REPLACE(REPLACE(:storecode, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
}

if(!!_inparam.sotrename) {
  _sqlBuilder.push(" and storename like CONCAT(CONCAT('%',REPLACE(REPLACE(:storename, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
  _countSqlBuilder.push(" and storename like CONCAT(CONCAT('%',REPLACE(REPLACE(:storename, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ");
}

_sqlBuilder.push(rule_res.where_sql);
_countSqlBuilder.push(rule_res.where_sql);

_sqlBuilder.push(" order by updatetime desc ");

//分页
if(!!_pagingParam) {
    _sqlBuilder.push(" limit :pagesize offset :offset ");
}

var _sql = _sqlBuilder.join("");
var _countsql = _countSqlBuilder.join("");

var tmp = SQL.query(_sql, params);
var countres  = SQL.queryForString(_countsql, params);

OUT.kx_kq_store = tmp;

//输出分页
if(!!_pagingParam) {
    OUT.__paging = {"__pageindex":  _pagingParam.__pageindex, "__pagesize": _pagingParam.__pagesize, "__itemcount": countres};
}





60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
用到API
js
var rule_res = SQL.getRuleSql(ruleobj,rule_objmaps,rule_extraparam);
1
注：

ruleobj 查询的规则对象的名称 如： kx_kq_store
rule_objmaps 查询语句中用到的数据对象 对象名、表名、别名 如：
js
var rule_objmaps = [
  {
    "objectmark": "kx_kq_store",
    "tablename": "kx_kq_store",
    "alias": "kx_kq_store"
  }
];

6
7
rule_extraparam 额外参数
rule_res 结果
js
{
  "join_sql": "",
  "where_sql": "",
  "rule_param": {}
}

取到结果后，需要把语句与原本查询语句，进行合并，把 rule_param 与原查询语句的参数进行合并
3.2. 扩展库
扩展库由平台扩展的一些通用库，需要通过 load('库名') 引用。

3.4. 工作流
flycode中可调用工作流服务，操作预设流程的发起和提交，获取当前流转的流程信息。

3.4.1. 当前流程信息
API

js
// 加载模块
load('workflow');
1
2
js
/**
* 当前流程信息
*/
class WorkflowInfo

4
实例化 WorkflowInfo 即可获得当前的流程相关信息

js
// WorkflowInfo 数据结构
{
    "af_processinstanceid": "",                 // 流程实例Id
    "af_processinstancename": "",               // 流程实例名称
    "af_processdefineid": "",                   // 流程定义Id
    "af_processdefinename": "",                 // 流程定义名称
    "af_applyusercode": "",                     // 流程发起人编码
    "af_hasend": "",                            // 流程状态，是否已结束
    "prestate": {                               // 流程提交前参数
        "af_taskname": "",                      // 用户任务名称
        "af_choicename": "",                    // 审批选项名称
        "af_comments": ""                       // 审批意见
    },
    "forwardstate": [                           // 后续流程节点信息
        {
            "af_taskid": "",                    // 用户任务实例Id
            "af_taskkey": "",                   // 用户任务Key 【忽略】
            "af_taskname": "",                  // 用户任务名称
            "af_handler": ""                    // 处理人
        }
    ]
}



13
14
15
16
17
18
19
20
21
22
例: 获取当前的流程定义名称，当前审批意见，并记录日志

js
load('workflow');
var wf = new WorkflowInfo();

FLY.log(
        " 流程-> 名称:" + wf.af_processdefinename +
        " 审批意见:" + wf.prestate.af_comments
);

6
7
3.4.2. 流程发起
API


load('workflow');   // 加载流程模块
WORKFLOW.allocate();  // 发起流程,默认取当前成员作为发起人
WORKFLOW.allocate('<发起人>') // 发起流程重载的方法，传递的参数为发起人
WORKFLOW.allocate(<流程对象自定义>) // 发起流程,默认取当前成员作为发起人。需要自定义流程对象信息的，可加入
WORKFLOW.allocate('<发起人>', <流程对象自定义>) // 发起人和流程对象都可自定义

示例


load('workflow');

// 保存请假单对象
var leave = IN.kx_leave;
var startDate = new Date(leave.starttime);
var endDate = new Date(leave.endtime);

leave.applydate = NOW.time();
leave.approvalstatus = '待审批';
DB.insert(leave);

// 发起流程
WORKFLOW.allocate();

// 发起流程(如:订单录入员)
WORKFLOW.allocate(IN.kx_order.inputer);

// 流程对象自定义(修改流程实例名称)
WORKFLOW.allocate({'af_processinstancename':'自定义实例名'});

// 更新审批状态
IN.kx_leave.approvalstatus = '草稿';
DB.update(IN.kx_leave);



13
14
15
16
17
18
19
20
21
22
23
3.4.3. 流程提交
API


load('workflow');   // 加载流程模块
WORKFLOW.submit();  // 流程提交
WORKFLOW.submit(<自定义对象>); // 用于传递复杂逻辑的处理

示例


load('workflow');

// 保存请假单对象
var leave = IN.kx_leave;
var startDate = new Date(leave.starttime);
var endDate = new Date(leave.endtime);

// 保存对象
DB.update(IN.kx_leave);

WORKFLOW.submit();  // 提交流程

WORKFLOW.submit({'params':{'iswork':'true'}});  // 提交流程，并传递自定义信息。本例假设传递一个是否工作的参数给流程引擎使用
// 更新审批状态
if (WF.choice == '终止') {
    IN.kx_leave.approvalstatus = '已中止';
} else if (WF.choice == '退回') {
    IN.kx_leave.approvalstatus = '已驳回';
} else {
    if (WF.taskname == '文员(行政)核对') {
        if (WF.choice == '同意') {
            IN.kx_leave.approvalstatus = '审批通过';
        } else if (WF.choice == '不同意') {
            IN.kx_leave.approvalstatus = '审批不通过';
        }
    } else {
        IN.kx_leave.approvalstatus = '审批中';
    }
}

DB.update(IN.kx_leave);




25
26
27
28
29
30
31
3.4.4. 流程外部终止
API


load('workflow');   // 加载流程模块
WORKFLOW.terminal('<业务Id>', '<流程定义Key>', '<终止原因>');  // 终止流程
1
2
示例


load('workflow');
var order = IN.order;
var orderid = leave.orderid;
WORKFLOW.terminal(orderid, null, '订单废弃，自动终止');


3.4. 消息
API

js
// 模块加载
load('message');
1
2
java
/**
* 消息数据
**/
class MsgData {
    String text;        // 文本
    var detail;         // 详情，可以是 流程信息 WorkflowInfo
}

6
7
java
/**
* 消息样式
**/
class MsgStyle {
    boolean showtitle;  // 显示标题: true 显示, false 不显示
    String displaytype; // 显示类型: MSG.DISPLAYTYPE_ONLYTEXT 仅文本
    boolean showdetail; // 显示详情: true 显示, false 不显示
}


java
/**
* 消息请求包
**/
class MTRequest {
    String title;       // 标题
    String msgtype;     // 消息类型: MSG.TYPE_REMIND 提醒, MSG.TYPE_NOTICE 通知
    MsgStyle style;     // 显示样式，详见 MsgStyle类
    MsgData msgdata;    // 消息数据，详见 MsgData类
}


9
js
/**
* 发送消息
**/
MSG.send(MTRequest);

4
js
/**
* 发送短信
**/
MSG.sendsms(MTRequest);

4
例: 发送当前审批流程的待处理提醒消息

js
// 加载模块
load('message');

// 获取当前流程节点信息
var workflowInfo = new WorkflowInfo();

// 包装消息体
var msgdata = new MsgData();
msgdata.text = "您发起的申请已经审批完成申请编号：" + workflowInfo.instanceid;
msgdata.detail = workflowInfo;

// 定义消息显示样式
var style = new MsgStyle();
style.showtitle = true;
style.displaytype = MSG.DISPLAYTYPE_ONLYTEXT;
style.showdetail = false;

// 包装消息请求
var req = new MTRequest();
req.title = "待处理提醒";
req.msgtype = MSG.TYPE_REMIND;
req.style = style;
req.msgdata = msgdata;

// 发送
MSG.send(req);




25
26
例: 发送短信

js
/**
 * 时间：2018-8-13
 * 描述： 终端智能推送列表
 */
// 模块加载
load('message');

var result = [
  {
    "type":"5001",
    "msg":"7月销量累计占比排名前50%的终端",
    "names":"7-11便利店、全家便利店、喜士多便利店、乐尔康超市、喜多多便利店、沃尔玛超市"
  },
   {
    "type":"5003",
    "msg":"7月同比销量下滑终端",
    "names":"7-11便利店、全家便利店、喜士多便利店、乐尔康超市、喜多多便利店、沃尔玛超市"
  },
    {
     "type":"5003",
    "msg":"7月产品铺货率下滑终端",
    "names":"7-11便利店、全家便利店、喜士多便利店、乐尔康超市、喜多多便利店、沃尔玛超市"
  },
    {
    "type":"5004",
    "msg":"7月生动化合格率下滑终端",
    "names":"7-11便利店、全家便利店、喜士多便利店、乐尔康超市、喜多多便利店、沃尔玛超市"
  }
];

var info = {};
info.image = [];
info.text = '199994便利店、全家便利店、喜士多便利店、乐尔康超市、喜多多便利店、沃尔玛超市';
info.param = {};
info.param.type = "5001";
info.param.datetime = (new Date()).getTime();
FLY.log(JSON.stringify(info));

var msgDetail = function(){
  var msg = {};
  msg.title = "title月销量累计占比";
  msg.summary = ""
  msg.jsondata = JSON.stringify(info);
  msg.handler = "1037268760265887744";
  msg.alertTitle = "";
  msg.alertDigest = "";
  return msg;
}

  var msgdata = new MsgData();
  msgdata.text = JSON.stringify(info);
  msgdata.detail = [];
    msgdata.jsondata = {};
  var mebercodes = ["1037268760265887744","976362040903995392","975552983515402240","978100998570643456"];
  for(var i in mebercodes){
    var detail = {"handler":mebercodes[i],"title":"","summary":""};
   // msgdata.detail.push(detail); 975552780976656384
  }
    msgdata.detail.push(msgDetail());
  FLY.log(JSON.stringify(msgdata.detail));
  // 定义消息显示样式
  var style = new MsgStyle();
  style.showtitle = true;
  style.displaytype = MSG.DISPLAYTYPE_ONLYTEXT;
  style.showdetail = true;

  // 包装消息请求
  var req = new MTRequest();
  req.title = "7月销量累计占比排名前50%的终端888";
  req.msgtype = '5001';
  req.style = style;
  req.summary ="终端表现智能推送";
  req.msgdata = msgdata;
  req.alerttitle = '终端表现智能推送';
  req.alertdigest = '您有一条终端表现智能推送消息';

  // 发送短信
  MSG.sendsms(req);


3.5. 平台帐号管理
平台账号服务的API仅限于特殊账号才可使用

3.5.1. 新增账号
API

js
// 加载模块
load('account');
1
2
js
// 新增账号，返回 新增的账号ID
ACCOUNT.add('<用户名1>', '<用户名2>', '<用户名3>');
1
2
例: 新增一个账号的例子

js
var accountcode = ACCOUNT.add(
    '210001',
    '1389999999',
    'brown@xtion.net');

4
3.5.2. 启用账号
API

js
ACCOUNT.enable('<账号ID>');
1
3.5.3. 停用账号
API

js
ACCOUNT.disable('<账号ID>');
3.6. 系统配置
获取系统配置的json，系统配置的KEY可在IDE中查看

API

js
// 系统配置模块加载
load('sysconfig');
1
2
js
CONFIG.get('<系统配置Key>');
1
例: 获取账号注册的配置项

js
var temp = CONFIG.get('register');
FLY.log(JSON.stringify(temp));
3.7. 汉字拼音转换
API

js
// 模块加载
load('pinyin');
1
2
js
PINYIN.get('<汉字字符串>')     // 汉字转小写拼音
PINYIN.getshort('<汉字字符串>') // 汉字转小写拼音简写
1
2
例: 将汉字转换为拼音字符串

js
// 加载拼音转换库
load('pinyin');

var pinyinName = PINYIN.get('业务模型');
var pinyinShortName = PINYIN.getshort('业务模型');

// 记录日志
FLY.log(pinyinName);
FLY.log(pingyinShortName);
3.8. 高德地图服务
提供高德地图开发API接口的封装

库加载

js
// 模块加载
load('amap');
.8.1. 地理编码解析
接口说明: 用于地址转换经纬度

js
方法定义:

MAPUTIL.transferAddress('<地址字符串>', '<是否做逆地址解析>');

返回值：
{
    "latitude": "",
    "longitude": "",
    "address": ""
}


9
10
示例:

js
load('amap');
var addressname = '广东省广州市天河区天河南街道维多利广场VT101';
var formatAddress = MAPUTIL.transferAddress(addressname, true);
FLY.log(formatAddress.address);         // 地址 如：广东省广州市天河区天河南街道维多利广场VT101
FLY.log(formatAddress.latitude);        // 纬度 如：23.1348494466146
FLY.log(formatAddress.longitude)        // 经度 如：113.320592990451

6
3.8.2. 逆地理编码解析
接口说明: 用于经纬度转换地址

js
方法定义:

MAPUTIL.transferLocation('<经度>', '<纬度>');

返回值：
{
    "latitude": "",
    "longitude": "",
    "address": ""
}


9
10
示例:

js
load('amap');
var formatAddress = MAPUTIL.transferLocation('113.320592990451','23.1348494466146');
FLY.log(formatAddress.address);         // 地址 如：广东省广州市天河区天河南街道维多利广场VT101
FLY.log(formatAddress.latitude);        // 纬度 如：23.1348494466146
FLY.log(formatAddress.longitude)        // 经度 如：113.320592990451


3.9. opendata服务
提供对http、webservice、数据库查询及更新的API调用接口的封装

库加载

js
// 模块加载
load('opendata');
.9.1. http接口调用
接口说明: 用于调用http请求

js
方法定义:

OPENDATA.http(参数);

返回值：
{
    "result": ""
}


参数：

参数名	必选	类型	说明
url	是	string	url地址
method	是	string	请求方式：post、get
bodyType	否	string	参数类型：json，xml等
headerMap	否	string	header参数
bodyMap	否	object	body参数
如果bodyMap是字符串参数，比如json字符串、xml字符串，要使用bodystr作为默认key来接收参数：

参数名	必选	类型	说明
bodystr	是	object	参数可以为对象（非字符串），或者字符串（json,xml）
参数示例：

js
{
    "url":"http://127.0.0.1/test",
    "method":"post",
    "bodyType":"json",
    "headerMap":{
        "Content-Type":"application/json"
    },"bodyMap":{
        "bodystr":"{"test":"1234"}"
    }
}


9
10
示例:

js
load('opendata');

var url = 'http:/' + '' + '/restapi.amap.com/v3/geocode/regeo?output=JSON&key=9264b1fa01fea091c2b2b5bcc8f56b4d&location=116.578168%2C30.632763';
var rst1 =
{
 "url":url,
 "method":"get",
 "headerMap":{ "Content-Type":"application/json"}
};

var openrst= OPENDATA.http(rst1);
FLY.log(openrst);   // {result={"status":"1","regeocode":{"addressComponent":{"city":"安庆市","province":"安徽省","adcode":"340882","district":"潜山市","towncode":"340882100000","streetNumber":{"number":"187号","location":"116.578217,30.6328931","direction":"北","distance":"15.194","street":"梅苑路"},"country":"中国","township":"梅城镇","businessAreas":[[]],"building":{"name":[],"type":[]},"neighborhood":{"name":[],"type":[]},"citycode":"0556"},"formatted_address":"安徽省安庆市潜山市梅城镇梅苑路187号皖山购物广场"},"info":"OK","infocode":"10000"}}



3.9.2. DB查询接口调用
接口说明: 用于数据库查询，支持sqlserver，postgres,mysql等数据库

js
方法定义:

OPENDATA.query(参数);

返回值：结果集，json格式
[{
    "查询列1": "",
    "查询列2": "",
     ...
}]


9
10
参数：

参数名	必选	类型	说明
dbType	是	string	数据源类型
address	是	string	数据源地址
port	是	string	端口
databaseName	是	string	数据源
userName	是	string	账号
password	是	string	密码
sql	是	string	查询脚本
queryParams	是	list	查询参数
参数示例：

js
{
    "dbType":"POSTGERS",
    "address":"address",
    "port":"3432",
    "databaseName":"database",
    "userName":"userName",
    "password":"password",
    "sql":"select * from tb_user where xx=? limit 10",
    "queryParams":["xx"]
}


9
10
示例:

js
load('opendata');

var url = "172.16.0.126";
var sql = "select * from cmdb_plataccount where username1 = ?";
var params = ["test111"];

var rst1 =
{
 "dbType":"postgresql",
 "address":url,
 "port":15432,
 "databaseName":"xw_plat_env",
 "userName":"postgres",
 "password":"csb123456",
 "sql":sql,
 "queryParams":params
};

var openrst= OPENDATA.query(rst1);
FLY.log(openrst); // [{createtime=2020-06-23 16:54:49.0, salt=7, orgcode=8, remark=null, plataccountcode=1275351593121878016, password=fc5ede25dc5d97723386da04bcf49015, contact=test111, username2=null, username1=test111, createop=999999, updatetime=2020-06-23 16:54:49.0, status=2, updateop=999999}]



13
14
15
16
17
18
19
20
3.9.3. DB更新接口调用
接口说明: 用于数据库批量更新，支持sqlserver，postgres,mysql等数据库

js
方法定义:

OPENDATA.update(参数);

返回值：
{
    "result": [] // 影响条数
}


参数：

参数名	必选	类型	说明
dbType	是	string	数据源类型
address	是	string	数据源地址
port	是	string	端口
databaseName	是	string	数据源
userName	是	string	账号
password	是	string	密码
sql	是	string	更新脚本
updateParams	是	二维数组	执行参数
paramTypes	是	list	执行参数的类型
参数示例：

js
{
    "dbType":"POSTGERS",
    "address":"127.0.0.1",
    "port":"3432",
    "databaseName":"database",
    "userName":"111",
    "password":"password",
    "sql":"update table set xx=@xx where id=@id",
    "updateParams":[["xx","id"],["xx","id"]],
    "paramTypes":["varchar","int4"]
}
或
{
    "dbType":"POSTGERS",
    "address":"127.0.0.1",
    "port":"3432",
    "databaseName":"database",
    "userName":"111",
    "password":"password",
    "sql":"update table set xx=? where id=?",
    "updateParams":[["xx","id"],["xx","id"]],
    "paramTypes":["varchar","int4"]
}



13
14
15
16
17
18
19
20
21
22
23
示例:

js
load('opendata');

var url = "172.16.0.126";
var sql = "update cmdb_plataccount set remark=? where username1 = ? and status = ?";
var updateParams = [["12","testuser",1],["12","tester",1]];
var paramTypes = ["varchar","varchar","int4"];

var rst1 =
{
 "dbType":"postgresql",
 "address":url,
 "port":5432,
 "databaseName":"xw_plat_env",
 "userName":"postgres",
 "password":"123456",
 "sql":sql,
 "updateParams":updateParams,
  "paramTypes":paramTypes
};

var openrst= OPENDATA.update(rst1);

FLY.log(openrst); //  {result=[1, 1]}



13
14
15
16
17
18
19
20
21
22
23
3.9.4. webservice接口调用
接口说明: 用于调用webservice接口

js
方法定义:

OPENDATA.ws(参数);

返回值：
{
    "result": "" //结果集
}


参数：

参数名	必选	类型	说明
url	是	string	请求地址
userName	是	string	账号
password	是	string	密码
method	是	string	请求方法
params	是	list	执行参数
参数示例：

js
{
    "url":"http://127.0.0.1/soap/test?wsdl",
    "userName":"",
    "password":"",
    "method":"getMade_upArtData",
    "params":["1","2","3"]
}

6
7
示例:

js
load('opendata');

var url = "http:/"+"/127.0.0.1/soap/test?wsdl";

var rst1 =
{
    "url":url,
    "method":"getMade_upArtData",
    "userName":"",
    "password":"",
    "params":["1","2","3"]
};

var openrst= OPENDATA.ws(rst1);
FLY.log(openrst);

1.1 流程应用接口
1.1.1 流程预发起
说明
流程预发起接口：用于获取流程定义基本信息以及发起UI的配置信息；

url
POST API: ~/workflow/flow/preaddflow

RequestBody
json
{
    "af_processdefinekey": "p_896215376495513600"  //流程定义Key
}

ResponseBody
json
{
    "resp_data": {
        "af_processdefineid": "p_896215376495513600:21:1185497075681464320",// 流程定义Id
        "af_processdefinekey": "p_896215376495513600",// 流程定义Key
        "af_processdefinename": "请假单",// 流程定义名称
        "af_uiconfig": { // UI配置信息
            "mobileui": {
                "pagecode": "896207527157567562",// UI编码
                "controlmanager": null,// UI控制逻辑，630不考虑
                "submitbuttoncode": "button-ctrl_button_save",// 指定UI提交按钮控件Code
                "businessobjname": "kx_leave",// 业务对象名称
                "businessobjpropertyname": "leaveid"// 业务对象标识属性名称
            },
            "webui": {
                "pagecode": "895833338005295154",
                "controlmanager": null,
                "submitbuttoncode": "button-ctrl_button_save",
                "businessobjname": "kx_leave",
                "businessobjpropertyname": "leaveid"
            },
            "actions": {
                "submitlogicmodelcode": "908881091400700003",// 提交行为模型编码
                "submitlogiccode": "908954560385650787",// 提交行为
                "applylogicmodelcode": "908881091400700003",// 发起行为模型编码
                "applylogiccode": "908897639783862364",// 发起行为
                "withdrawmodelcode": "",
                "withdrawlogiccode": "",
                "abandonmodelcode": "",
                "abandonlogiccode": "",
                "deletemodelcode": "",
                "deletelogiccode": "",
                "tempsavemodelcode": "",//v3.2 暂存行为模型编码
                "tempsavelogiccode": ""//v3.2 暂存行为
            }
        },
        "af_instancenamerule": "le:user('userinfoname') + '的请假单'"  // 流程实例名生成规则
    }
}




25
26
27
28
29
30
31
32
33
34
35
36
37
38
1.1.2 获取下一步信息
说明
获取下一步步骤信息接口，用于选择下一步人员

url
POST API: ~/workflow/flow/predictnextstepinfo

RequestBody
json
{
    "af_processdefineid": "p_896215376495513600:21:1185497075681464320",//流程定义id
    "af_taskid": "1301699355702595585",//任务id
    "af_choice": 1,//审批选项
    "af_choicename": "同意",//审批选项名称
    "af_bizinfo": {//业务信息, object-map形式，与发起和提交的业务数据格式相同
        "kx_leave": {
            "leaveid": "1113342551156461898",
            "usercode": "1026669501686617054",
            "leavetype": "895840294887624704",
            "applydate": "1599113400000",
            "starttime": "1599113400000",
            "endtime": "1599199800000",
            "remark": "",
            "attachments": "[]",
            "datespan": "8",
            "images": "[]",
            "approvalstatus": "草稿"
        }
    }
}



13
14
15
16
17
18
19
20
21
ResponseBody
json
{
    "resp_data": {
        "af_nodekey": "sid-46F7DE00-B629-4A8A-A5DB-80AE82381AB4,nodekey2",//节点Key //v3.2 流转的节点..有可能为空 （即多人审批，未达到流转的条件时） 多个时以逗号分隔
        "af_nodetype": "userTask",//节点类型
        "af_typename": "用户任务",//节点类型名
        "af_nodename": "上级领导审批",//节点名称 //v3.2 多个情况下，以逗号分隔 (不同意退回情况下，会出现此种情况)
        "af_jointnode": false,//是否为多实例节点 v3.2定义有调整，并非为会审节点的定义概念
        "af_mode": "manual",//
        "af_pick": "1",//选人策略 1 单选 2 多选 0 不用选择人(用于会审中多人，还不可以进入到下一步) //v3.2增加  3 指定 由这些人进行审批 (用于流转处理时，回退后的处理情况)
        "af_turntype": "",//流转类型 fallback(普通退回) | sendback(退回一种，允许直送回退回节点) | directsend 直送退回节点 | forward(向前) | nochange(不改变：处理多人审批或未达到流转条件时) 空（兼容：按照旧逻辑处理） //v3.2 定义 //v3.3 是否直送审批 由审批人选择 choiceback (选择选项：sendback、fallback)
        "af_nodecandidates": [// 可选人员范围信息
            {
                "af_memberid": "1185027297384730624",//成员id
                "af_membername": "主管",//成员姓名
                "af_phonenumber": "15603004002",
                "af_postid": "1183568138374090752",
                "af_postname": null,
                "af_parentpostid": null,
                "af_orgid": "1183564545248071680",
                "af_orgname": "销售点1",
                "af_parentorgid": "1183564207958921216",
                "af_refpostid": "888000000000000003",//职位id
                "af_refpostname": "主管"//职位
            }
        ],
        /*前端在选择不同的退回节点时，
        根据 选择退回的节点key,
        从af_backmembers中筛选出不同退回节点退回的成员，
        成员的具体信息，依旧存放在af_nodecandidates（当退回为多个时，是所有可退回节点成员）
        */
        "af_backmembers": {//如果是非多退回节点时，此节点可能忽略输出 //v3.2 解决不同意多选退回节点情况
            "sid-46F7DE00-B629-4A8A-A5DB-80AE82381AB4": "1185027297384730624,memberid2",
            "nodekey2": "memberid1,memberid2"
        }
    }
}




25
26
27
28
29
30
31
32
33
34
35
36
1.1.3 列表查询
说明
获取待办、已办接口、我发起的、我收到

查询时间定义
待办： 任务的接收时间 作为时间范围查询

已办： 任务的处理时间 作为时间范围查询

我发起: 申请任务的接收时间(发起时间) 作为时间范围查询

我收到的: 任务的接收时间 作为时间范围查询

url
POST API: ~/workflow/flow/getmyprocesslist

RequestBody
json
{
    "af_pageindex":1,           //页码
    "af_pagesize":10,           //页大小
    "af_querytype": 0,          //查询类型，待办:0, 已办:1, 我发起：2, 我收到：3.   默认查待办 v3.2，增加了2，3类型
    "af_querycondition": {
        "processinstancename": "",  // like 流程实例名 or 流程定义名称 or 发起人
        "processdefinename": "",    // like 流程定义名称
        "applyusername": "",        // like 发起人
        "startdate":    "",         // 流程开始时间  内部查询时间定义，看上面定义
        "enddate":  "",             // 流程结束时间
        "key": "",//流程key
        "categorycode": "",//分类编码
        "categoryname": "",//分类名称
        "categorytype": "",// 1-业务类，2-办公类
        "flowstate": "",//流程状态 单选  v3.2  //  0|空 全部 （默认），1 审批中 ，2 审批完成，3 已撤销
        "categorycodes": "",//分类编码 支持多选 多个以逗号分隔  v3.2
        "processinstanceid": "",//流程实例id v3.3
        "urge": "1"//v3.3 待办列表  是否催办  1 找催办记录 ， 空 查找全部
    }
}



13
14
15
16
17
18
19
20
ResponseBody
json
{
    "resp_data": {
        "af_pagecount": 1,//总页数
        "af_pagesize": 20,//每页大小
        "af_itemcount": 16,//记录总数
        "af_items": [
            {
                "af_processdefineid": "p_896215376495513600:21:1185497075681464320",//流程定义id
                "af_processinstanceid": "1211923438059524096",//流程实例id
                "af_processinstancename": "XX的请假单",//流程实例名称
                "af_processdefinekey": "p_896215376495513600",//流程定义key
                "af_processdefinename": "请假单",//流程定义名称
                "af_taskid": "1211923440651603968",//任务id
                "af_taskkey": "sid-46F7DE00-B629-4A8A-A5DB-80AE82381AB4",//任务key
                "af_taskname": "上级领导审批",//任务名称
                "af_createtime": 1577780039357,//任务创建时间
                "af_endtime": 1577780039357,//任务结束时间 待办为空
                "af_assigned": true,//是否已设置处理人
                "af_applyusercode": "1169909387230318592",//流程发起人id
                "af_applyusername": "XX",//发起人姓名
                "af_applytime": 1577780038740,//申请时间
                "af_isfallback": false,//是否退回
                "af_statusname": "处理中",//状态
                "af_businesskey": "1210510625986449446",//业务id
                "af_categorycode": "100000000",//类别编码
                "af_categoryname": "办公相关",//类别名称
                "af_taskownername": "test",//邀请人 //v3.2 用于展示评论的邀请人姓名
                "af_taskstatus": "",//任务状态 //v3.2 用于评论列表，显示 未评论、已评论、已过期
                "af_urge": "1" //v3.3 待办列表 是否催办 1: 是
            }
        ]
    }
}




25
26
27
28
29
30
31
32
33
待办列表
af_statusname : 草稿、处理中、退回、撤回

已办列表
af_statusname : 不通过、通过、已结束（旧数据）、处理中、已终止

我申请
af_statusname : 草稿、退回、撤回、处理中、已终止、不通过、通过、已结束

我收到
af_statusname : 草稿、退回、撤回、处理中、已终止、不通过、通过、已结束

1.1.4 获取审批明细
说明
获取审批明细接口，从待办或已办进入审批时调用

任务类别:
apply: 是代表任务为申请任务
task： 是一个正常的审批任务
review：是一个评论任务
sendback: 是一个可以直送回退回节点的审批任务
fallback: 是一个被退回的审批任务
contersign：是一个加签的审批任务
delegate: 是一个代理代办的审批任务
withdraw:是一个申请人撤回后，审批任务类型
recall:是指被申请人撤回时，生成一个被撤回的任务信息

url
POST API: ~/workflow/flow/getflowstepdetail

RequestBody
json
{
    "af_processinstanceid": "1301699354846957568",//流程实例Id
    "af_taskid": "1301699355702595585",//任务Id
    "af_taskkey": "af_initiatetask",//任务Key
    "af_processdefineid": "p_896215376495513600:21:1185497075681464320" //流程定义Id
}

6
ResponseBody
json
{
    "resp_data": {
        "af_processdefineid": "p_896215376495513600:21:1185497075681464320",//流程定义Id
        "af_processdefinekey": "p_896215376495513600",//流程定义Key
        "af_processdefinename": "请假单",//流程定义名称
        "af_processinstanceid": "1301699354846957568",//流程实例id
        "af_processinstancename": "某某某请假单",//流程实例名称
        "af_taskid": "1301699355702595585",// 任务Id
        "af_taskkey": "af_initiatetask",//任务key
        "af_taskname": "发起人提申请",//任务名称
        "af_createtime": "2020-09-04 09:51:25",//任务创建时间
        "af_taskcategory": "",//当前任务类别 //v3.2 task sendback recall fallback withdraw contersign delegate review apply
        "af_group": "",//任务分组 //v3.2
        "af_taskuiconfig": {//节点UI配置信息
            "mobileui": {
                "pagecode": "896207527157567562",// UI编码
                "controlmanager": null,// UI控制逻辑，不在此实现，由页面写uiflycode控制//v3.x 会有定义。定义结构后续补充
                "submitbuttoncode": "button-ctrl_button_save",// 指定UI提交按钮控件Code
                "businessobjname": "kx_leave",// 业务对象名称
                "businessobjpropertyname": "leaveid"// 业务对象标识属性名称
            },
            "webui": {
                "pagecode": "895833338005295154",
                "controlmanager": null,
                "submitbuttoncode": "button-ctrl_button_save",
                "businessobjname": "kx_leave",
                "businessobjpropertyname": "leaveid"
            },
            "actions": {
                "submitlogicmodelcode": "908881091400700003",// 提交行为模型编码
                "submitlogiccode": "908954560385650787",// 提交行为
                "applylogicmodelcode": "908881091400700003",// 发起行为模型编码
                "applylogiccode": "908897639783862364",// 发起行为
                //<code>新增了另外几个事件的</code>//new
                "withdrawmodelcode": "908881091400700003",//撤回
                "withdrawlogiccode": "111111111",
                "abandonmodelcode": "908881091400700003",//终止
                "abandonlogiccode": "2222222222",
                "deletemodelcode": "908881091400700003",//删除
                "deletelogiccode": "333333333333"
            }
        },
        "af_hashandle": false,// 是否已处理（决定页面审批UI元素的显示或隐藏)
        "af_hasend": false,//流程是否已结束
        "af_businesskey": "1113342551156461898",//业务数据主键Id
        "af_choices": [//列出当前步骤可操作的功能行为
            {
                "af_choice": 1, // 选项code
                "af_choicename": "同意", // 选型value
                //在此补入逻辑编码？ //v3.2
                "modelcode": "",//执行提交模型编码
                "logiccode": ""//执行提交的行为编码
            },
            {
                "af_choice": 2,
                "af_choicename": "不同意",
                "modelcode": "",
                "logiccode": ""
            }
        ],
        "af_jointnode": false,// 当前任务节点是否为会审节//v3.2 定义有调整，更改为是否为多实例节点
        "af_processtraces": [ // 流程审批记录追踪
            {
                "af_actid": "sid-251EA43B-BCB3-4CC8-8681-9749FAEA2BDF",// 活动Key
                "af_actname": "开始",// 活动名称
                "af_acttype": "startEvent",// 活动类型
                "af_assigneecode": null,//处理人编码
                "af_assignee": null,//处理人姓名
                "af_handletime": "2020-09-04 09:51:25",//处理时间
                "af_comments": null,//审批意见 //兼容af_commentlist
                "af_choice": null,   // 审批选择
                "af_choicename": null, // 审批选择名称
                //v3.1 增加返回属性
                "af_orgname": "快销V8.5.1-base开发租户",
                "af_phonenumber": "13012345677",
                "af_postname": "主管",
                "af_refpostname": "主管",
                "af_taskid": "1332206597367271426",
                //v3.2
                "af_reviews": [//评论信息
                    {
                        "af_type": "review",//评论
                        "af_time": "2020-09-04 09:51:25",
                        "af_msg": "xxxxxx"
                    }
                ],
                "af_group": "",//任务分组 //v3.2
                "af_taskcategory": "",//任务类别 //v3.2 task sendback recall fallback withdraw contersign delegate review apply
                //v3.3
                "af_copysend": "[{\"id\":\"1\",\"name\":\"张三\"}]",//v3.3 //json 字符串，记着抄送的人的id和姓名？ 列出会知的人的姓名？需要变为一个 数组对象
                //如何区分，是任务的分享和已办的时候的分享？
                "af_attachments": [//v3.3 附件数据
                    {
                        "af_type": "attachment",//附件
                        "af_time": "",//上传时间
                        "af_msg": "",//包括附件名称\url等信息 json //前端的附件json定义结构？
                    }
                ],
                //v3.3额外输出
                "af_ptaskid":"",//父任务id，表达此任务是由那个任务派生出来。 目的，是为了以后，要构造成一颗树状数据展示？
                "af_jumpintype": "",//进入此任务的原因（类型）
                "af_starttime": ""//任务的接收时间（创建任务时间）
            }
        ],
        "af_status": "",//流程状态 //v3.3 处理中等同于af_taskcategory 结束的，为流程实例的结束标记 delete_reason_的定义
        "af_statusname": "",//流程状态名称 //v3.3 用于展示详情中的状态名称 结合 af_hasend=true 来决定是否显示
        "af_urge": "1"//v3.3 是否催办(催办等级？) //不一定用上，先定义在此
    }
}





60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
1.1.5 获取可退回节点列表
说明
获取可退回的节点列表, 用于流程退回的场景

url
POST API: ~/workflow/flow/getfallbacknodelist

RequestBody
json
{
    "af_taskkey": "sid-46F7DE00-B629-4A8A-A5DB-80AE82381AB4",//当前节点key
    "af_processinstanceid": "1301699354846957568",//流程实例id
    "af_processdefineid": "p_896215376495513600:21:1185497075681464320"//流程定义id
}

ResponseBody
json
{
  "resp_data": [
    {
      "af_nodekey": "af_initiatetask",                // 可退回的节点Key
      "af_nodeName": "发起人申请",                 // 可退回的节点名称
    }
  ]
}


1.1.6 获取选定的退回节点的详细信息
说明
获取选定的退回节点的详细信息, 用于流程退回的场景

url
POST API: ~/workflow/flow/getfallbacknodedetail

RequestBody
json
{
    "af_taskkey": "af_initiatetask",                            // 选定的退回节点Key
    "af_processinstanceid": "1301699354846957568",              // 流程实例Id
    "af_processdefineid": "p_896215376495513600:21:1185497075681464320"     // 流程定义Id
}

ResponseBody
json
{
    "resp_data": {
        "af_nodekey": "af_initiatetask",
        "af_nodetype": "userTask",
        "af_typename": "用户任务",
        "af_nodename": "发起人提申请",
        "af_jointnode": false,
        "af_mode": "manual",
        "af_pick": "1",
        "af_nodecandidates": [
            {
                "af_memberid": "1169909332268158976",
                "af_membername": "王娟",
                "af_phonenumber": "17665028612",
                "af_postid": "1161900362488221696",
                "af_postname": "主管",
                "af_parentpostid": null,
                "af_orgid": "1",
                "af_orgname": "快销V8.5.1-base开发租户1",
                "af_parentorgid": null,
                "af_refpostid": "888000000000000003",
                "af_refpostname": "主管"
            }
        ]
    }
}




25
26
1.1.7 获取流程分类明细
说明
获取流程分类明细，明细中列出该分类下的流程列表

用于手机端，获取流程分类，有根据功能权限获取有授权的流程
v3.2 更改为web端也可使用此接口 同样，web也要做 流程功能点授权，才会有对应数据

url
POST API: ~/workflow/flow/getflowcategorydetail

RequestBody
json
{
}
1
2
ResponseBody
json
{
    "resp_data": [
        {
            "af_flowcategorycode": "100000000",//流程分类编码
            "af_flowcategoryname": "办公相关",//流程分类名称
            "af_parentcode": "0",
            "af_status": 1,//分类状态
            "af_categorytype": 0,//分类类别
            "af_processlist": [
                {
                    "af_processkey": "p_1167025417535901696",//流程key
                    "af_processname": "月度出差评估申请"//流程名称
                }
            ]
        }
    ]
}



13
14
15
16
17
1.1.8 流程发起
说明
流程发起

注：发起接口，是由业务引擎包装，调用。一般不建议直接微服务调用

需要用flycode调用，在调用流程引擎发起接口前或后，进行其他的业务数据处理

url
POST API: ~/workflow/flow/allocateflow

flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_processdefinekey": "p_896215376495513600",// 流程定义Key
        "af_processinstancename": "某某某请假单",//流程实例名
        "af_businessobjname": "kx_leave",//业务对象名
        "af_businessobjpropertyname": "leaveid",//业务对象标识属性名称
        "af_processinstanceid": ""//为了兼容处理草稿，不做发起处理的处理  //v3.2 定义
        //需要注意一点，是对应的业务逻辑的flycode 对业务数据的处理，也要去判断，是否已经存在数据的处理保存
    },
    "kx_leave": {//业务数据
        "leaveid": "1113342551156461898",
        "usercode": "1026669501686617054",
        "leavetype": "895840294887624704",
        "applydate": "1599113400000",
        "starttime": "1599113400000",
        "endtime": "1599199800000",
        "remark": "",
        "attachments": "[]",
        "datespan": "8",
        "images": "[]",
        "approvalstatus": "草稿"
    }
}



13
14
15
16
17
18
19
20
21
22
23
ResponseBody
json
//流程实例对象
{
    "af_processdefineid": "testFlow:1:868035529109803008",      // 流程定义Id
    "af_processinstanceid": "868041669533110272",               // 流程实例Id
    "af_taskid": "868041669658939392",                          // 发起后的任务实例Id
    "af_businesskey": ""                                        // 业务数据标识值
}

6
7
1.1.9 流程提交
说明
注：提交接口，是由业务引擎包装，调用。一般不建议直接微服务调用

需要用flycode调用，在调用流程引擎提交接口前或后，进行其他的业务数据处理

同意不同意的操作，进入提交的逻辑接口

增加了抄送 af_notifyusers v3.3

url
POST API: ~/workflow/flow/submitflow

flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "发起人提申请",//任务名称
        "af_choice": "1",//审批选项
        "af_choicename": "同意",//审批选项名称
        "af_comments": "审批意见",//审批意见
        "af_jointnode": false,//下一步节点是否为多实例节点 //v3.2 定义调整
        "af_nextstepusers": "1185027297384730624",// 下一步人员Id，多个用逗号分隔（会审）
        "af_processinstanceid": "1301699354846957568",//流程实例id
        "af_taskid": "1301699355702595585",//任务id
        "af_businessobjname": "kx_leave",//业务对象名称
        "af_businessobjpropertyname": "leaveid",//业务对象标识属性名称
        "af_fallbacknodekey": "",//回退时选择的回退节点Key //v3.2 注：此属性不止退回时有值，在提交时，按照获取下一步接口返回的af_nodekey填充
        "af_currentjoinnode": false,// 当前节点是否为多实例节点 //v3.2 定义调整
        "af_turntype":"",//v3.2 提交时，根据获取下一步接口返回的数据，写入
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
        "af_attachment": "[{\"url\":\"/xxx/xxxx/gdsgd.jpg\",\"filename\":\"\",\"type\":\"\"}]"//v3.3 附件 前端附件json结构  注：普通任务在提交的同时并上传附件时使用 ？ 附件上传，是与提交操作分开处理？
    },
    "kx_leave": {//业务数据入参
        "leaveid": "1113342551156461898",
        "usercode": "1026669501686617054",
        "leavetype": "895840294887624704",
        "applydate": "1599113400000",
        "starttime": "1599113400000",
        "endtime": "1599199800000",
        "remark": "",
        "attachments": "[]",
        "datespan": "8",
        "images": "[]",
        "approvalstatus": "草稿"
    }
}




25
26
27
28
29
30
31
32
ResponseBody
json
{//调用flycode返回的数据
    "resp_data":{
        "__approvaldata":{"af_processinstanceid":"1301699354846957568"}
    }
}

json
{//调用流程引擎服务，返回数据
    "resp_data": "流程实例id"
}

1.1.10 流程实例删除
说明
需要在流程配置中，定义删除行为指定
流程在草稿状态下，允许可以删除处理
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "申请",
        "af_choice": 9,//
        "af_choicename": "删除",//
        "af_comments": "",
        "af_jointnode": false,
        "af_nextstepusers": "",
        "af_processinstanceid": "1411946336068575232",//必须
        "af_taskid": "1411946336110518272",//必须
        "af_fallbacknodekey": "",
        "af_currentjoinnode": false,
        "af_turntype": ""
    },
    "kx_leave":{
        "leaveid":"1210174455765444252"
    }
}



13
14
15
16
17
18
ResponseBody
json
//200
{"resp_data":{"__approvaldata":{"af_processinstanceid":"1411946336068575232"}}}
1
2
1.1.10.1 批量流程实例删除
说明
支持批量删除

ids 根据流程实例id去删除
bizids 根据业务数据id去删除
改为调用flycode，再调用WORKFLOW.delete() 单个处理
需求上，只能用于草稿状态的流程。即存在于发起步骤，未做提交过的数据
不建议直接调用微服务接口

url
POST

~/workflow/flow/batchDelete

RequestBody
json
{//流程实例id
    "ids": "123,345"
}

或

json
{//业务数据id
    "bizids": "123,456"
}

ResponseBody
json
{//200 正常
    "resp_data": ""
}

1.1.11 更换处理人
说明
更换处理人 把代办任务中属于 oldassignee 的任务 转给 assignee

把多个离职人员的待办任务，转给新的处理人
(注：这个接口，是不记录至流程历史上，是直接替换处理人的方式)

由实施配置页面，去处理 是在业务引擎上调用服务注册的方法

url
POST

~/workflow/flow/changeAssignee

RequestBody
json
{
    "assignee": "1234567",//新的处理人成员id
    "oldassignee": "33333333444,232312324"//待更换的处理人的成员id
}

4
ResponseBody
json
{//200 正常
    "resp_data": ""
}

1.1.12 终止流程
说明
申请人，撤回后，可以终止流程
终止操作，可以同时进行抄送 v3.3五丰需求
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "申请",
        "af_choice": 3,
        "af_choicename": "终止",
        "af_comments": "终止原因",
        "af_jointnode": false,
        "af_nextstepusers": "",
        "af_processinstanceid": "1417730517285081088",
        "af_taskid": "1418512314751524865",
        "af_businessobjname": "kx_leave",
        "af_businessobjpropertyname": "leaveid",
        "af_fallbacknodekey": "",
        "af_currentjoinnode": false,
        "af_turntype": "",
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
    },
    "kx_leave": {
        "leaveid": "1410174472765444249"
    }
}



13
14
15
16
17
18
19
20
21
ResponseBody
json
{"resp_data":{"__approvaldata":{"af_processinstanceid":"1417730517285081088"}}}
1
1.1.12.1 外部中止流程
说明
中止流程，可以由申请人或其他与此流程相关的人员，进行直接流程终止

如果中止流程，需要处理业务数据，建议接口是用flycode去包装，直接用 WORKFLOW.terminal('<业务Id>', '<流程定义Key>', '<终止原因>'); // 终止流程

url
~/workflow/flow/terminateflow

RequestBody
json
{
    "af_businesskey": "",//业务主键 必须参数
    "af_processdefinekey": "",//流程定义key 可以为空
    "af_comments": "",//终止原因 可以为空
    "af_choicename": ""//可以为空，默认为 外部中止
}

6
ResponseBody
json
{
    //200 正常
}

1.1.13 流程撤回
说明
申请人，对自己已经发起的流程（未结束、终止状态），可进行撤回
非申请人，对自己提交的任务，可进行主动撤回？ 暂不支持（v3.3五丰需求，是允许可以撤回）
撤回的规则：任务未处理时，可以进行撤回

由于撤回的操作，有可能涉及到业务数据状态的调整修改，需要业务引擎服务进行包装接口 (有待商议)

业务上，用flycode来对接接口，并非直接调用流程引擎服务的接口

v3.3 af_fallbacknodekey 为空时，并不默认为 "af_initiatetask"，如果不传入时，将根据 af_taskid查找出撤回的节点

url
微服务接口 (不建议直接调用微服务接口)

~/workflow/flow/withdrawflow

flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "",//任务名称 //可以为空
        "af_choice": "5",//审批选项  //必须参数
        "af_choicename": "撤回",//审批选项名称
        "af_comments": "撤回原因",//撤回的原因
        "af_nextstepusers": "",//为空
        "af_processinstanceid": "1301699354846957568",//流程实例id //必须参数
        "af_taskid": "1301699355702595585",//任务id  //
        "af_businessobjname": "",//业务对象名称 //为空，可以不写
        "af_businessobjpropertyname": "",//业务对象标识属性名称 为空，可以不写
        "af_fallbacknodekey": "",//撤回的节点的key，空值时，默认为 发起步骤  "af_initiatetask" v3.3 把此值，也补上，用于发送消息时好判断是申请撤回还是其他步骤撤回
        "af_turntype": "withdraw",//
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
    },
    "kx_leave": {//业务数据入参 //撤回时，流程引擎不需要此参数，但业务逻辑，需要用此对象参数去更新业务状态
        "leaveid": "1113342551156461898"
    }
}



13
14
15
16
17
18
19
ResponseBody
json
{
    //200 正常
}

1.1.14 流程加签
说明
需要指定加签的行为逻辑
多人审批时，不允许加签处理
加签处理，可以抄送 v3.3 五丰需求
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "stepb-1",
        "af_choice": 11,
        "af_choicename": "加签",
        "af_comments": "加签意见说明",
        "af_jointnode": false,
        "af_nextstepusers": "1332159698773872640",
        "af_processinstanceid": "1353657254159065088",
        "af_taskid": "1417386115740475394",
        "af_businessobjname": "",
        "af_businessobjpropertyname": "",
        "af_fallbacknodekey": "",
        "af_currentjoinnode": false,
        "af_turntype": "",
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
    },
    "kx_leave": {
        "leaveid": "1345990523776800569"
    }
}



13
14
15
16
17
18
19
20
21
ResponseBody
json
{"resp_data":{"__approvaldata":{"af_processinstanceid":"1353657254159065088"}}}
1
撤回或退回后提交 直送
（提交至上一处理人的步骤活动）

说明
注：有待商议是否要开发此接口

如何规定出上一处理人的步骤活动？根据时间倒序？

此接口，不直接对外开放。由新的流程配置中，配置流转策略里去处理

url
~/workflow/flow/directapproval

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "当前任务名称",//任务名称
        "af_choice": "6",//审批选项  //必须参数
        "af_choicename": "直送",//审批选项名称
        "af_comments": "撤回原因",//撤回的原因
        "af_jointnode": false,//下一步节点是否会审节点
        "af_nextstepusers": "",//直送节点审批人
        "af_processinstanceid": "1301699354846957568",//流程实例id //必须参数
        "af_taskid": "1301699355702595585",//任务id
        "af_businessobjname": "",//业务对象名称
        "af_businessobjpropertyname": "",//业务对象标识属性名称
        "af_fallbacknodekey": "",//直送节点的key，空值时，由引擎找出最后一次的审批节点，进行直送？
        "af_currentjoinnode": false// 当前节点是否为会审节点
    },
    "kx_leave": {//业务数据入参 //撤回时，流程引擎不需要此参数，但业务逻辑，需要用此对象参数去更新业务状态
        "leaveid": "1113342551156461898",
        "usercode": "1026669501686617054",
        "leavetype": "895840294887624704",
        "applydate": "1599113400000",
        "starttime": "1599113400000",
        "endtime": "1599199800000",
        "remark": "",
        "attachments": "[]",
        "datespan": "8",
        "images": "[]",
        "approvalstatus": "草稿"
    }
}




25
26
27
28
29
ResponseBody
json
{
    //200 正常
}

1.1.15 流程转办
说明
转办流程

url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "xxxx",//当前任务节点名称
        "af_choice": "7",
        "af_choicename": "转办",
        "af_comments": "xxxxxxxxxxxxx",//转办原因
        "af_nextstepusers": "1177476231315197952",//转办人
        "af_processinstanceid": "1329612157758869504",
        "af_taskid": "1329687061615218688",
        "af_fallbacknodekey": "",
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
    },
    "kx_leave": {
        "leaveid": "1308327884846404564"
    }
}



13
14
15
16
ResponseBody
json
{
    //200 正常
}

1.1.16 流程沟通
说明
添加沟通人员
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "step1",
        "af_choice": 12,
        "af_choicename": "沟通",
        "af_comments": "",
        "af_jointnode": false,
        "af_nextstepusers": "1164791140730408960,1177475518312878080",//沟通人员
        "af_processinstanceid": "1351778407566286848",
        "af_taskid": "1351794037321375744",
        "af_fallbacknodekey": "",
        "af_turntype": ""
    },
    "kx_leave": {
        "leaveid": "1308327884846404553"
    }
}



13
14
15
16
17
ResponseBody
json
{"resp_data":{"__approvaldata":{"af_processinstanceid":"1351778407566286848"}}}
1
1.1.16.1 流程评论
说明
具有沟通的同时，可以发表评论意见
沟通人员，可以发表意见，不能加人
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "step1",
        "af_choice": 13,
        "af_choicename": "沟通",//名称同步跟着12的名称
        "af_comments": "磊大理石刚到公司",
        "af_jointnode": false,
        "af_nextstepusers": "",
        "af_processinstanceid": "1351778407566286848",
        "af_taskid": "1351794037321375744"
    },
    "kx_leave": {
        "leaveid": "1308327884846404553"
    }
}



13
14
15
ResponseBody
json
{"resp_data":{"__approvaldata":{"af_processinstanceid":"1351778407566286848"}}}
1
批量发起或提交
说明
用于批量发起同一流程，提交至下一步骤，且下一步骤处理人，为同一个人
(即创建流程实例，生成申请任务，并推向下一步骤)

v3.2 版本，可以用flycode 的方法，处理，不要用注册微服务方法去调用

url
POST API: ~/workflow/flow/batchHandle

RequestBody
json
{
    "af_processdefinename": "",//流程定义名称 //必须
    "af_processdefinekey":"",//流程key //必须
    "af_assignee": "",//申请人,为空时，为当前操作人
    "af_nextstepusers": "",//提交处理人 //必须  //有没有必要传入，还是由流程去计算出默认？提交人？
    "af_choice": "审批选择",//（1,2,3,4）//为空时，代表为发起流程
    "af_choicename": "审批选择的name",//(同意，不同意，中止，退回) //为空时，代表发起流程
    "af_comments": "审批意见",//可以为空
    "af_businessobjname": "业务对象名称",//可以为空 如：kx_leave
    "af_businessobjpropertyname": "业务对象标识属性名称",//可以为空
    "datas": [
        {
            "af_processinstancename": "",//实例名称 //可以为空，但生成的实例名称，为流程定义名称
            "af_businesskey": "",//业务id //必须
            "biz_objinfo": {}//业务对象信息  biz_objinfo是变化的， 如： kx_leave 根据不同的业务实体，而变化。//可以为空
        }
    ]
}



13
14
15
16
17
18
ResponseBody
json
{
    "err_msg": "",//错误提示
    "sucess": ""//成功的流程实例id返回
}

4
1.1.17 流程成员选择列表
说明
v3.2功能

是用flycode接口对接。用于加签或转办等功能时，由web|手机端，进行成员选择

url
POST API: ~/api/teapi/dy-biz/1039104191773151331/6666666666666666

RequestBody
json
{
    "af_member_search":{
        "af_keyword":"key",//用于关键字匹配查询：  姓名、手机号码、组织名称、岗位名称、职位名称
        "af_processdefinename":"",//当前流程定义名称
        "af_taskname":""//当前流程步骤名称
    },
    "__paging":{
        "__pageindex":"0",//分页码
        "__pagesize":"20"//分页大小
    }
}


9
10
11
ResponseBody
json
{
    "resp_data": {
        "__paging": {
            "__itemcount": "25",
            "__pageindex": "0",
            "__pagesize": "20"
        },
        "af_member": [
            {
                "af_postid": "1183565836573609984",//岗位id
                "af_memberid": "1305686373679894528",//成员id
                "af_phonenumber": "13900000003",//手机号码
                "af_orgname": "TPM总公司",//组织名称
                "af_refpostid": "1183565708471177216",//职位id
                "__metaname": "pl_orgstruct",
                "af_membername": "434",//姓名
                "af_orgid": "1162189884690141184",//组织id
                "af_refpostname": "key全部权限",//职位名称
                "af_postname": "key全部权限"//岗位名称
            }
        ]
    }
}



13
14
15
16
17
18
19
20
21
22
23
1.1.18 流程组织成员选择树
说明
v3.2功能

是用flycode接口对接。用于加签或转办等功能时，由web|手机端，进行成员选择

展示形式为树。

只能选择成员的，不能选择组织

id parentid 构造树数据

category : 1 组织 3 成员

af_memberid 成员id

url
POST API: ~/api/teapi/dy-biz/1039104191773151331/6666666666668888

RequestBody
json
{
    "af_member_search":{
    },
    "__paging":{
        "__pageindex":"0",//分页码
        "__pagesize":"20000"//分页大小
    }
}


ResponseBody
json
{
    "resp_data": {
        "__paging": {
            "__itemcount": "20000",
            "__pageindex": "0",
            "__pagesize": "20000"
        },
        "af_membertree": [
            {
                "id": "id",
                "parentid": "父id",
                "category": "1",//1 组织 3 成员
                "af_memberid": "1305686373679894528",//成员id
                "af_membername": "434",//姓名
                "af_phonenumber": "13900000003",//手机号码
                "af_orgname": "TPM总公司",//组织名称
                "af_refpostid": "1183565708471177216",//职位id
                "af_orgid": "1162189884690141184",//组织id
                "af_refpostname": "key全部权限",//职位名称
                "af_postid": "1183565836573609984",//岗位id
                "af_postname": "key全部权限",//岗位名称
                "level": "",//数据层级
                "seq": ""//顺序
            }
        ]
    }
}




25
26
27
1.1.19 流程待处理数量
说明
v3.2功能

待办列表的红点数量代表待办流程的总数；

阅示邀请的红点数量代表可以发表评论，但还没有发表评论的流程数量。

url
POST API: ~/workflow/flow/getmyprocesscount

RequestBody
json
{
}
1
2
ResponseBody
json
{
    "resp_data": {
        "reviewcount": 1,//待评论数量
        "todocount": 35//待办数量
    }
}

6
1.1.20 流程所有待办数据分页列表
说明
所有待办流程数据，分页列表

用于某些管理人员，可以针对所有待办流程数据，进行操作（如：终止、转办处理)

列表的顺序，以流程实例的申请时间（发起时间）倒序，进行排序

v3.3 版本需求

url
POST API: ~/workflow/flow/getToDoPageList

RequestBody
json
{
    "af_pageindex":1,           //页码
    "af_pagesize":10,           //页大小
    "af_querycondition": {
        "keyword": "",//关键字查询 like 流程实例名 or 流程定义名称 or 发起人姓名
        "processinstancename": "",// like 流程实例名
        "processdefinename": "",// like 流程定义名称
        "applyusername": "",//like 发起人
        "applystartdate": "2021-04-01",//申请时间开始时间
        "applyenddate": "2021-06-08",//申请时间结束时间
        "taskstartdate": "2021-04-01",//待办任务开始时间
        "taskenddate": "2021-06-08",// 待办任务开始时间
        "taskusername": "王娟",//like 任务处理人
        "taskname": "初审",//like 任务名称
        "key": "p_11111111111",//流程key =
        "categorycode": "100000001",//分类编码  =
        "categoryname": "",//分类名称 =
        "categorytype": "",// 1-业务类，2-办公类 =
        "categorycodes": "",//分类编码 支持多选 多个以逗号分隔
        "processinstanceid": ""//流程实例id
    }
}



13
14
15
16
17
18
19
20
21
22
ResponeseBody
json
{
    "resp_data": {
        "af_pagecount": 1,//分页总数
        "af_pagesize": 20,//每页大小
        "af_itemcount": 2,//总记录数
        "af_items": [
            {
                "af_processinstanceid": "1397021345069932544",//流程实例id
                "af_applyusername": "王娟",//申请人姓名
                "af_taskname": "初审",//任务名称 步骤名称
                "categorycode": "100000001",//分类code
                "af_applytime": 1621910818741,//申请时间 发起时间
                "af_taskkey": "sid-50C63D06-F37E-40B6-A2F3-FE7BCE833502",//任务key
                "af_applyusercode": "1169909387230318592",//申请人id
                "af_processinstancename": "1621910761501验证流程",//流程实例名称（标题）
                "af_processdefineid": "p_1397012142439403520:1:1397019778027229184",//流程版本定义id
                "af_assignee": "1169909332268158976",//处理人id
                "af_taskid": "1397021366469271554",//任务id
                "af_processdefinekey": "p_1397012142439403520",//流程key
                "af_processdefinename": "lht_测试新流程改名1",//流程定义名称
                "af_createtime": 1621910823825,//任务开始时间
                "af_businesskey": "1294187413920420763",//业务id
                "categoryname": "办公类",//分类名称
                "af_taskusername": "王娟"//任务处理人
            }
        ]
    }
}




25
26
27
28
1.1.21 批量终止流程实例
说明
用于流程管理员，在所有的待办流程数据列表中，选择勾选，进行批量终止流程实例

注：由于需要发送消息，弃用了此API

v3.3 版本需求

url
POST API: ~/workflow/flow/batchTerminate

RequestBody
json
{
    "af_choice": "3",
    "af_choicename": "终止",//由外部传入？具体名称
    "af_comments": "",//终止原因 必填？
    "af_datas": [
        {
             "af_processinstanceid": "1397021345069932544",
             "af_taskid": "1397021366469271554"
        },
        {
            "af_processinstanceid": "1397021345069932542",
             "af_taskid": "1397021366469271552"
        }
    ]
}



13
14
15
ResponeseBody
json
//200
1
1.1.22 批量变更处理人
说明
用于流程管理员
在所有的待办流程数据列表中，选择勾选，进行批量的任务转办处理
不勾选，直接指定原处理人，及转办人，进行批量的转办处理 (需求上不支持，一定要批量选择任务)
注：由于需要发送消息，弃用了此API

v3.3 版本需求

url
POST API: ~/workflow/flow/changeAssigneeByTask

RequestBody
json
{
    "af_choice": "7",
    "af_choicename": "转办",
    "af_comments": "",//转办原因
    "af_nextstepusers": "1111111111",//转办人 //新的处理人
    "af_oldassignee": "222222222",//原处理人 //如果为空时， af_datas必须有值，以具体的任务进行转办
    "af_datas": [//如果任务为空时。即为把某个人的所有任务，转办给新的处理人
        {
            "af_processinstanceid": "1397021345069932544",
             "af_taskid": "1397021366469271554"
        }
    ]
}



13
Responsebody
json
//200
1
1.1.23 审批管理终止
说明
flycode 实现
批量操作
需要实现信息的发送
v3.3 版本需求

url
POST API: ~/api/teapi/dy-biz/1039104191773151331/6666666666668881

RequestBody
json
{
    "af_action": {
        "af_choice": "3",
        "af_choicename": "终止",
        "af_comments": "",//终止原因 必填？
    },
    "af_datas": [
        {
            "af_processinstanceid": "1397021345069932542",
            "af_taskid": "1397021366469271552",
            "af_processdefineid": "p_1397012142439403520:1:1397019778027229184",
            "af_taskkey": "sid-50C63D06-F37E-40B6-A2F3-FE7BCE833502",
            "af_assignee": "1169909332268158976",
            "af_businesskey": "1294187413920420763"
        }
    ]
}



13
14
15
16
17
ResponseBody
json
//单个成功 //全部成功
{
    "resp_data": {
        "__dataprocessresult": [
            {
                "message": "终止完成",
                "params": {},
                "type": "info"//warn
            }
        ]
    }
}



json
//有提示错误
{
    "resp_data": {
        "__dataprocessresult": [
            {
                "message": "总共\\(totalcount)条，成功\\(successcount)条，失败\\(errorcount)条",
                "params": {
                    "totalcount": "8",
                    "successcount": "5",
                    "errorcount": "3"
                },
                "type": "info"
            }
        ]
    }
}



13
14
15
16
1.1.24 审批管理变更处理人
说明
flycode 实现
批量操作
需要实现信息的发送
v3.3 版本需求

url
POST API: ~/api/teapi/dy-biz/1039104191773151331/6666666666668882

RequestBody
json
{
    "af_action": {//操作定义
        "af_choice": "7",
        "af_choicename": "转办",
        "af_comments": "",//转办原因
        "af_nextstepusers": "1111111111",//转办人 //新的处理人
    },
    "af_datas": [
        {
            "af_processinstanceid": "1397021345069932544",
            "af_taskid": "1397021366469271554",
            "af_processdefineid": "p_1397012142439403520:1:1397019778027229184",
            "af_taskkey": "sid-50C63D06-F37E-40B6-A2F3-FE7BCE833502",
            "af_assignee": "1169909332268158976",
            "af_businesskey": "1294187413920420763"
        }
    ]
}



13
14
15
16
17
18
ResponseBody
json
//单个成功 //全部成功
{
    "resp_data": {
        "__dataprocessresult": [
            {
                "message": "变更完成",
                "params": {},
                "type": "info"//warn
            }
        ]
    }
}



json
//有提示错误
{
    "resp_data": {
        "__dataprocessresult": [
            {
                "message": "总共\\(totalcount)条，成功\\(successcount)条，失败\\(errorcount)条",
                "params": {
                    "totalcount": "8",
                    "successcount": "5",
                    "errorcount": "3"
                },
                "type": "info"
            }
        ]
    }
}



13
14
15
16
1.1.25 审批附件上传
说明
在沟通评论，可以上传附件
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "stepa-1",
        "af_choice": "14",
        "af_choicename": "上传附件",
        "af_processinstanceid": "1417730517285081088",//流程实例id
        "af_taskid": "1417730517310246913",//任务id
        "af_attachment": "[{\"url\":\"/xxx/xxxx/gdsgd.jpg\",\"filename\":\"\",\"type\":\"\"}]"//v3.3 附件 前端附件json结构
    },
    "kx_leave": {
        "leaveid": "1308327884846404556"
    }
}



13
ResponseBody
json
//200
1
1.1.26 审批催办
说明
申请人，在我发起的，未结束的流程，可以进行催办
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "申请",
        "af_choice": "17",
        "af_choicename": "催办",
        "af_comments": "1",//可以为空，默认写1
        "af_processinstanceid": "1417730517285081088",//流程实例id
        "af_taskid": "1417730517310246913"//任务id
    },
    "kx_leave": {
        "leaveid": "1308327884846404556"
    }
}



13
ResponseBody
json
//200
1
1.1.27 审批分享
说明
流程结束后，能看到任务的人，都可以进行分享
url
flycode接口

POST API: ~/api/teapi/dy-biz/{modelcode}/

RequestBody
json
{
    "__approvaldata": {
        "af_taskname": "申请",
        "af_choice": "16",
        "af_choicename": "分享",
        "af_processinstanceid": "1417730517285081088",//流程实例id
        "af_taskid": "1417730517310246913",//任务id
        "af_notifyusers": "[{\"id\":\"1\",\"name\":\"张三\",\"pname\":\"职位\"}]",//v3.3 抄送|分享 选择的人 数组json
    },
    "kx_leave": {
        "leaveid": "1308327884846404556"
    }
}



13
ResponseBody
json
//200

3.3.1. Excel导入导出
3.3.1. Excel导入导出

3.3.1.1. EXCEL导入

3.3.1.1.1. 导入配置

3.3.1.1.1.1. 实施专用配置（类似java项目的properties文件）
3.3.1.1.1.2. web端用户专用配置（类似java项目的properties文件）
3.3.1.1.1.3. 实施、web端共用配置（类似存储过程的入参）
3.3.1.1.1.4. 导入缓存配置
3.3.1.1.2. 数据绑定对象（类似mybatis的resultMap）

3.3.1.1.2.1. 数据校验
3.3.1.1.3. 特殊需求处理

3.3.1.1.4. 统计忽略导入的行

3.3.1.1.5. 跨表头导入

3.3.1.2. EXCEL导出

3.3.1.2.1. 导出绑定对象数组（类似mybatis的resultMap）

3.3.1.2.1.1. web端用户专用配置（类似java项目的properties文件）
3.3.1.2.2. 抽取数据库数据

3.3.1.2.3. 导出操作

3.3.1.2.4. 导出操作

3.3.1.2.5. 跨列父表头

3.3.1.2.6. 注意事项

3.3.1.2.7. 导出格式扩展

3.3.1.3. EXCEL复杂结构导出方案

3.3.1.1. EXCEL导入
excel导入数据是按行来导入的，每行数据都会执行一次flycode，前一行导入出错不影响后一行的导入，同一行数据导入出错的时候，会回滚该行的导入。

3.3.1.1.1. 导入配置
3.3.1.1.1.1. 实施专用配置（类似java项目的properties文件）
这些配置描述导入excel的数据抽取规则，不会影响flycode的代码执行逻辑。
实施在flycode代码开始处（不需要在ide上配置入参），必须定义“_xlsconf”对象，该对象的属性即为实施专用配置。该对象目前有两个属性：1、startindex，表示从sheet页的第几行开始导入。2、isOrderExtract，表示将按行的顺序导入excel（会影响导入速度）。后续flycode代码中不能使用“_xlsconf”对象。
注意：“_xlsconf”对象只能一次性定义，不支持在flycode中添加、删减、修改对象属性。

示例：

js
var _xlsconf = {
     //指定将从sheet页的第N行开始导入。注意：第0行为列名行
    "startindex" : "N",
    // true表示顺序导入， false表示不顺序导入（默认）
    "isOrderExtract" : "true"
}

6
3.3.1.1.1.2. web端用户专用配置（类似java项目的properties文件）
这些配置描述导入excel的数据抽取规则，不会影响flycode的代码执行逻辑。
由实施在ide配置入参，web端用户传参。参数名不能以下划线“_”开头（参数名以下划线开头的参数有特殊用途，可见3.8.1.1.3. 实施、web端共用配置）。主要用来描述待导入的一些信息。如下所示：

js
{
    "xls_test": {
        //指定了导入哪些sheet。传空数组表示导入全部sheet
        "sheetnames":"[\"华南sheet\",\"华北sheet\"]",
        //导入的excel在文件系统的路径
        "excelname":"http://172.16.0.125:7000/file/img/20170522/1008199/input1.xlsx"
    }
}


3.3.1.1.1.3. 实施、web端共用配置（类似存储过程的入参）
实施在flycode定义“paramobj”全局对象作为共用配置对象，web端用户可以选择覆盖这个对象的属性（只能覆盖属性名以下划线“\”开头的属性）。“_paramobj”对象可以被flycode代码引用，进而达到控制flycode执行逻辑的目的。使用方法如下：

步骤一：实施在flycode中一次性定义“_paramobj”全局对象作为参数对象，禁止实施人员在后续flycode中添加、删减、修改对象属性。该对象可以被后续flycode代码引用。如下所示：

js
var _paramobj = {
//重复行导入策略： 1：更新；2：追加；3：忽略
"_dupstrategy" : "1"
}

4
步骤二：如果web端用户想覆盖实施的定义，则需要实施在ide上配置入参，由web端用户传参，参数名必须以“_”开头。如下所示：

js
{
"xls_test":{
    //重复行导入策略： 1：更新；2：追加；3：忽略
    "_dupstrategy":"3"
}
}

6
此后，在flycode执行之前，“_paramobj”对象的_dupstrategy属性会被平台替换成web端用户的定义，如下所示：

js
_paramobj._dupstrategy = "3";
1
步骤三：后续flycode代码中，可以直接使用“_paramobj”对象。比如使用该对象做一些流程控制，如下所示：

js
if(_paramobj._dupstrategy == 1){
//执行更新
}else if(_paramobj._dupstrategy == 2){
//执行追加
}else if(_paramobj._dupstrategy == 3){
//执行忽略
}else{
//抛出异常
}


9
3.3.1.1.1.4. 导入缓存配置
为了避免导入逻辑频繁访问数据库，从而造成导入执行效率低的问题，专门为导入逻辑引入缓存配置；该缓存只对一次导入执行有效，即是局部缓存。该配置适用于小结果集的缓存，比如字典数据。

缓存配置
js
var _cache_brandList = select d.dictionaryid,d.dicvalue,d.keypath,d.status
                    from kx_productbrand d RULE("pl_salearea");
var _cache_storelevels = select d.dictionaryid,d.dicvalue,d.status
                    from kx_storelevel d NORULE;

4
注意：虽然该配置与flycode的查询语法一致，但不支持参数查询以及权限黑白名单占位符方式，必须是‘var _cache_xxx =’ 开头,查询结果集将会缓存到xxx中

定义缓存后，缓存对象将被注入到'CTX'容器中，在flycode中的应用：
js
//使用缓存：
if(!String.isBlank(IN.kx_storelevel.dicvalue)){
    var storelevel = null
    for(var j = 0,len = CTX.storelevels.length;j<len;j++){
        if(CTX.storelevels[j].dicvalue == IN.kx_storelevel.dicvalue){
            storelevel =  CTX.storelevels[j]
            break;
        }
    }
    if(storelevel == null){
       errMsg = errMsg + ("[终端级别]不存在！请在新增页面中，查看有效的终端级别;");
    }else if(storelevel.status == 2){
       errMsg = errMsg + ("[终端级别]已经停用;");
    }else{
         IN.kx_kq_store.storelevel = storelevel.dictionaryid;
    }
}



13
14
15
16
17
js
// 不使用缓存：
if(!String.isBlank(IN.kx_storelevel.dicvalue)){
  var storelevels = select d.dictionaryid,d.parentdictionaryid,d.status
                    from kx_storelevel d
                    where d.dicvalue = {IN.kx_storelevel.dicvalue} NORULE;
  if(storelevels == null || storelevels.length == 0) {
    errMsg = errMsg + ("[终端级别]不存在！请在新增页面中，查看有效的终端级别;");
  }else if(storelevels[0].status == 2){
    errMsg = errMsg + ("[终端级别]已经停用;");
  }else{
    IN.kx_kq_store.storelevel = storelevels[0].dictionaryid;
  }
}



13
3.3.1.1.2. 数据绑定对象（类似mybatis的resultMap）
该对象决定了业务对象的列和excel的列的对应关系，指导平台生成业务对象的入参。
命名方式："_bind_ + 业务对象名"，由实施人员在flycode中一次性定义，禁止在后续flycode中添加、删减、修改对象属性。后续flycode不能引用该对象。如下所示：
flycode绑定对象定义:

js
var  _bind_xls_test = { //业务对象名为“xls_test”
    "name" : "姓名",
    "credit" : "学分",
    "birthday" : "生日",
    "money" : "金额"
}

6
待导入的excel数据如下所示：

js
姓名    学分     生日      金额
张三    99    2017-1-1    2.22
1
2
执行flycode之前，平台会根据上述配置，自动封装入参，如下所示：

js
IN.xls_test = {
    "name" : "张三",
    "credit" : "99",
    "birthday" : "2017-1-1",
    "money" : "2.22"
}

6
3.3.1.1.2.1. 数据校验
数据校验函数由用户自己定义。如果数据有误，则抛出异常，系统将把异常的描述信息作为错误信息excel的错误描述。
示例：

js
//定义了金额校验函数，金额必须大于0
function moneyValFun(param1){
    print("开始调用moneyValFun了");
    if(parseInt(param1) <= 0){
        throw new ERROR("金额必须大于0！");
    }
}
//调用校验函数
moneyValFun(IN.xls_test.money);


9
3.3.1.1.3. 特殊需求处理
平台不提供特殊需求的处理，一切特殊需求都放到flycode中处理。
比如某个特殊需求：在导入某行excel数据的时候，如果数据库中已经有该行数据，则认为该excel数据是重复数据，需要根据配置来进行更新、追加、忽略等数据库操作。flycode可以按照如下步骤进行处理：

步骤一：实施定义对象“_paramobj”（只有该对象的属性名以“_”开头的属性才能被web用户传参覆盖）的属性“_dupstrategy”,该属性在后续flycode中决定了特殊逻辑的处理策略。
js
var _paramobj = {
//重复行导入策略： 1：更新；2：追加；3：忽略
"_dupstrategy" : "1"
}

4
步骤二：定义数据绑定对象，如下所示：
js
//业务对象名为“xls_test”
var  _bind_xls_test = {
"name" : "姓名",
"credit" : "学分",
"birthday" : "生日",
"money" : "金额"
}

6
7
步骤三：需求中，认为name、credit都相同的数据即为重复数据。以name、credit为条件查询数据库，确认该数据是否是重复数据：
js
var xls_testdp = select count(*) num from xls_test where name={IN.xls_test.name} and credit={IN.xls_test.credit};
if(xls_testdp==null || xls_testdp.length == 0) {
throw new ERROR("查询xls_test的数目出错！");
}
if(xls_testdp[0].num == 0) {
//不是重复数据
}else{
//是重复数据
}


9
步骤四：执行重复数据处理逻辑：
js
if(xls_testdp[0].num == 0) {
//不是重复数据，直接插入数据库
DB.insert(IN.xls_test);
}else {
//该行数据是重复数据，根据重复行处理策略进行处理
if(_xlsconf.dupstrategy == 1){
    //更新。DB.update函数的非第一个参数将作为update语句的where条件
    //在本例中，将执行sql：update xls_test set birthday=? money=? where name=? and credit=?;
    DB.update(IN.xls_test, 'name', 'credit');
}else if(_xlsconf.dupstrategy == 2){
    //追加
    DB.insert(IN.xls_test);
}else if(_xlsconf.dupstrategy == 3){
    //忽略
}else{
    throw new ERROR("没有指定合法的重复行处理策略！");
}
}



13
14
15
16
17
18
3.3.1.1.4. 统计忽略导入的行
如果需要忽略某行的导入，把该行以及忽略导入原因导出到错误excel，并统计入被忽略的行总数，
执行

js
throw new ERROR("自定义忽略原因", "impignore");
1
3.3.1.1.5. 跨表头导入
如果需要做跨表头导入，例如：

序号	组合
分组1	分组2
1	数据1
2	数据3
绑定协议配置如下:

json
// 需要配置导入开始行做数据偏移
var _xlsconf = {
    "startindex" : "N",
}

// 字段映射使用 "-" 分隔组合字段与分组字段
var  _bind_xls_test = { //业务对象名为“xls_test”
    "id" : "序号",
    "data1" : "组合-分组1",
    "data2" : "组合-分组2"
}


9
10
11
3.3.1.2. EXCEL导出
3.3.1.2.1. 导出绑定对象数组（类似mybatis的resultMap）
该对象决定了flycode的js数据对象和excel的列的对应关系。
命名方式："_xlscolBind"，由实施人员在flycode中一次性定义，禁止在后续flycode中添加、删减、修改该对象属性。后续flycode不能使用该对象。该数组对象的每个对象都代表了一个属性名与Excel列名的映射关系，"field"代表对象属性，"column"代表excel列名, 如下所示：

js
var _xlscolBind = [
    {
        "field": "name",
        "column": "姓名"
    },
    {
        "field": "credit",
        "column": "学分"
    },
    {
        "field": "birthday",
        "column": "生日"
    },
    {
        "field": "money",
        "column": "金额"
    }
];



13
14
15
16
17
18
3.3.1.2.1.1. web端用户专用配置（类似java项目的properties文件）
这些配置描述导入excel的数据导出规则，不会影响flycode的代码执行逻辑。

js
{
    "xls_test": {
        //导出的sheet名
        "sheetname":"制定便捷计划",
        //导出的excel名
        "filename":" 导出.xlsx"
    }
}


3.3.1.2.2. 抽取数据库数据
通过执行select语句来抽取数据库数据。
flycode示例：

js
var param1 = {
    "name":"张三"
}
var temp = SELECT name , credit , money  FROM xls_test WHERE name like {param1.name};

4
执行上述flycode，系统将生成对象数组：

js
var temp = [ {name:张三, credit:99, money:22.2}, {name:张三2, credit:88, money:11.2} ];
1
3.3.1.2.3. 导出操作
由于flycode中“OUT”对象是默认输出对象，实施把js数据对象数组赋值给OUT.xlsdata对象即可视为完成导出操作。平台在生成导出excel的时候，会从OUT.xlsdata中抽取数据，并参照导出绑定对象（见3.8.2.1），最终生成excel文件。
导出完整步骤如下所示：

步骤一：实施定义导出绑定对象
3.3.1.2.4. 导出操作
执行“OUT._xlsData = temp;”即可导出excel，其中temp为导出数据对象数组。
示例：

js
var _xlscolBind = [
{
    "field": "name",
    "column": "姓名"
},
{
    "field": "credit",
    "column": "学分"
},
{
    "field": "birthday",
    "column": "生日"
},
{
    "field": "money",
    "column": "金额"
}
];



13
14
15
16
17
18
步骤二：构造js数据对象数组

js
var temp = [ {name:张三, credit:99, money:22.2}, {name:张三2, credit:88, money:11.2} ];
1
步骤三：把js数据对象数组赋值给OUT.xlsdata

js
OUT.xlsdata = temp;
1
执行完该flycode后，平台参照导出绑定对象“_xlscolBind”，最终生成如下excel：

js
姓名    学分    生日    金额
张三    99             22.2
张三2   88             11.2

3.3.1.2.5. 跨列父表头
某些需求需要导出跨列父表头，如下所示：

js
      终端信息                费用信息
终端编号    终端名称    费用编号    费用名称
    Z1       便利店1       F1       驻场费用

跨列父表头终端信息下设终端编号和终端名称，费用信息下设费用编号和费用名称。

新增“_xlsPcol1”对象来表示跨列表头（此为临时方案，后期会在IDE里进行配置）。“_xlsPcol1”中的“1”表示是第一行父表头，目前仅支持一行父表头。
完整flycode如下所示：

js
//定义跨列父表头对象
var _xlsPcol1 = [
    {
        "column": "终端信息",
        "span": "2" //表示跨两列
    },
    {
        "column": "费用信息",
        "span": "2"//表示跨两列
    }
]

//定义导出绑定对象数组
var _xlscolBind = [
    {
            "field": "zdbh",
            "column": "终端编号"
    },
    {
            "field": "zdmc",
            "column": "终端名称"
    },
    {
            "field": "fybh",
            "column": "费用编号"
    },
    {
            "field": "fymc",
            "column": "费用名称"
    }
]

//构造js数据对象数组
var temp = [ {zdbh:Z1, zdmc:便利店1, fybh:F1, fymc:驻场费用}];

//赋值
OUT.xlsdata = temp




25
26
27
28
29
30
31
32
33
34
35
36
37
注意：跨列表头对象、导出绑定对象数组内部元素的顺序将与导出的excel列的顺序一致

3.3.1.2.6. 注意事项
目前导出的最大行数为20000条。
导出时sql语句需要添加paging标记。

3.3.1.2.7. 导出格式扩展
导出格式支持，列宽度、数据类型、动态文本(kv映射)；在_xlscolBind中添加以下字段
新版导出的字段映射设置，仅支持列宽度和数据类型，动态文本可直接在flycode中处理，更加灵活。

json
_xlscolBind = [
    {
    "field": "映射字段名",
    "column": "excel列名",
    "width":"宽度：如:100",
    "type":"数据类型,默认:string；string 文本，double 数值型(可统计)",
    "dynamictext":{ // 动态文本
      "原数据1":"映射后的新数据1",
      "原数据2":"映射后的新数据2"
    }
},
]



例:

json
_xlscolBind = [
{
    "field": "storecode",
    "column": "性别",
    "width":"100",
    "type":"String",
    "dynamictext":{ // 数据中的99和88，将被映射为高分和低分。
      "99":"高分",
      "88":"低分"
    }
},


9
10
11
3.3.1.3. 复杂结构导出方案
对于非二维表的复杂结构导出, 比如多维数据透视表.建议仅实现二维数据导出.将复杂结构生成交由excel的宏命令去生成.

将复杂的结构生成事先编写excel宏命令,并保存为导出模板文件.
在IDE的文件管理中,上传导出模板.
导出服务提供 指定模板文件 ,如下:
js

// 在flycode可使用如下定义指定导出模板使用的文件.
var _xlscolTemplate = "文件key";

导出服务将根据以上关键字,引用导出模板,导出二维数据.并生成一个带有宏命令的excel文件.
使用以上方法,实现excel导出的无所不能.

3.3.2. Mock接口
当前端列表控件需要store对象的数据，在flycode逻辑未写好前，可以自定义数据返回作为测试使用。

例子: mock一个查询门店的接口，返回门店信息列表

js
OUT.store=[{"storeid":"1","storename":"门店1"},{"storeid":"2","storename":"门店2"}];
1
出参：

json
{
    "resp_data": {
        "store": [
            {
                "storename": "门店1",
                "storeid": "1"
            },
            {
                "storename": "门店2",
                "storeid": "2"
            }
        ]
    }
}

3.4.3 Excel导入
3.3.3 导入导出

3.3.3.1 Excel导入

3.3.3.1.1 Excel导入过程分解
3.3.3.1.2 Excel导入API
3.3.3.1.3 Excel导入场景例子
3.4.3.1 Excel导入
支持由实施自行组织，批量提交数据
支持临时表方式导入，从临时表中获取异常数据输出excel
支持主从数据导入，主与从数据，由开发都根据数据行判断，进行批量提交
支持多个sheet页不同逻辑处理
支持前端导入，直接把excel数据经过flycode转换后，输出为列表，用于表单控件绑定（编辑表格）
导入时，附加额外入参
支持flycode中变量，用于缓存一些转换数据处理，不需要每条数据，都查询
界面优化，每次点击导入，弹出当前进度页面
支持复杂多级列头定义
支持规范列头和非规范列头导入
支持原生语句提交，非提交的，可以用以前的flycode方式查询
3.4.3.1.1 Excel导入过程分解
执行过程图


入参介绍
json
{
    "impfile":{
        "sheetnames": "[\"CC客户\"]",//导入选择的sheet
        "fileurl": "c99/att/20200611/1008212/c991daca-a19c-4fd8-8759-fc02d637a96d.xlsx",//导入文件url
        "filename": "TT客户.xlsx",//导入的文件名
        "_dupstrategy": "1"//导入策略 1 覆盖 2 追加 3 放弃
    },
    "customer-param": {
        //自定义入参， IDE中定义的入参对象
    }
}


9
10
11
3.4.3.1.2 Excel导入API
加载
初始化加载导入处理类

js
//加载导入处理类 EXCELIMP
load("importutils");
1
2
获取当前导入的批次id
js
//批次号获取
var dynamicid = EXCELIMP.dynamicid;
1
2
入参获取
js
//入参
var inParam = EXCELIMP.getInputParam();
1
2
导入策略获取
js
//导入策略
var _dupstrategy = inParam.impfile._dupstrategy;
1
2
列头设置映射
设置导入的excel中，列头与数据表列的映射关系

js
var titlemappings = [{"column": "产品编码","field": "productcode", "type": "String"}];

//设置标题映射
EXCELIMP.setTitleMapping(titlemappings);

4
是否为前端导入
js
//设置为前端导入模式
EXCELIMP.setFrontImp(true);
1
2
excel数据行处理函数注入 (必需)
js
//excel数据行处理，参数传入excel数据行及自定义的参数入参
/* 参数的介绍
exceldata：
规范列头是一个  Map<String,Object>，根据列头设置进行转换映射  如： {"productname": "A","procutcode": "10001"}
非规则列头是一个  List<Object>   ["A",20,null,"饮料"]
customdata: 入参对象 与上面的 inParam 一样
sheetname: 当前数据所在sheet名称
sheetrownum: 当前数据所在excel行数，注：规范列头时，是从真正数据开始的，非规范列头，是包括非规范列头开始计算。都是从0开始
rowdata:原excel数据 List<Object> ["A",20,null,"饮料"]
*/
var excelRowDataHandle = function(exceldata, customdata,sheetname,sheetrownum,rowdata){
    //TODO 数据检查、生成提交的操作语句、忽略数据、错误数据、按批提交数据
}
//设置数据行处理
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);



13
14
15
sheet开始读取数据处理函数注入 (非必要)
js
/* 参数介绍
sheetname: 当前数据所在sheet名称
*/
var sheetDataStartLoopHandle = function(sheetname) {
    //TODO 变更列头映射
}
EXCELIMP.setSheetDataStartLoopHandle(sheetDataStartLoopHandle);

6
7
sheet数据读取完毕处理函数注入 (非必要)
js
/* 参数介绍
sheetname: 当前数据所在sheet名称
*/
var sheetDataEndLoopHandle = function(sheetname, sheetrownum) {
    //TODO 把sheet或sheet余下数据 提交
}
EXCELIMP.setSheetDataEndLoopHandle(sheetDataEndLoopHandle);

6
7
整个excel数据读取完毕处理函数注入 (非必要)
js
var excelDataEndLoopHandle = function() {
    //TODO 做数据提交，或者什么都不处理 处理其他的非导入的功能。。如流程、发邮件、消息等
}
EXCELIMP.setExcelDataEndLoopHandle(excelDataEndLoopHandle);

4
提交数据
对导入的数据，进行按批，进行数据提交

js
//数据提交参数
var execsqls = [];
//提交的exceldata数据
var exceldatas = [];

var sql = "insert | update .....";
var param = {"id":"xxx","name": "xxxx"};
var execsql = {"sql": sql, "param": param};
execsqls.push(execsql);
exceldatas.push(rowdata);//rowdata是来源于行数据的rowdata

//提交数据
EXCELIMP.commitData(execsqls,exceldatas);



13
忽略数据
导入策略为放弃时，需要对已经存在的数据，标记 放弃导入

js
//忽略处理
EXCELIMP.ignoreData("放弃导入", rowdata);//rowdata是来源于行数据的rowdata
1
2
错误数据
导入数据，数据检查有问题或有业务上检查出错，需要输出出错原因

js
var errMsg = "[产品名称]不能为空，是必填项";
EXCELIMP.errRecord(errMsg, rowdata);//rowdata是来源于行数据的rowdata
1
2
临时表处理结果输出
js
//临时表名称
var tempTableName = 'kx_kq_product_temp';
var excelDataEndLoopHandle = function() {
    //对临时表进行数据处理
    EXCELIMP.dealTemplateData(tempTableName);
}
//设置excel数据循环完毕后处理方法
EXCELIMP.setExcelDataEndLoopHandle(excelDataEndLoopHandle);


执行导入
js
//执行数据导入
EXCELIMP.execute();

//非规范列头导入 //excelRowDataHandle 传入的参数 exceldata 结构不一样
EXCELIMP.execute("2");

3.4.3.1.3 场景例子
自行定义按批提交数据
可以自行在flycode上，处理一个计数器，定义多少条数据进行提交一次数据（每100条数据，进行一次提交）
有可能存在非整除的，就在 excelDataEndLoopHandle 中进行余下数据提交
js
//注： 此部分只是flycode中的片断

load("importutils");

//提交数据计数器
var excelrow = 0;
//提交批次数量
var commitnum = 100;

//excel 数据
var exceldatas = [];
//数据提交参数
var execsqls = [];

//数据提交处理
var commitdata = function() {
  if(execsqls !=null && execsqls.length >0) {
    EXCELIMP.commitData(execsqls,exceldatas);
  }
  exceldatas = [];
  execsqls = [];
}

//excel数据行处理，参数传入excel数据行及自定义的参数入参
var excelRowDataHandle = function(exceldata, customdata,sheetname,sheetrownum,rowdata){
  var check_res = checkData(exceldata,rowdata);
  if(!!check_res) {
    EXCELIMP.errRecord(check_res,rowdata);
  } else {
    excelrow++;
    //处理生成提交语句 execsqls 赋值
    dealData(exceldata, customdata,rowdata);
  }
  //每100条数据，进行提交数据
  if(excelrow % commitnum == 0) {
    commitdata();
  }
}

//设置数据行处理
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//excel数据循环完毕后
var excelDataEndLoopHandle = function() {
  //把余下的数据进行提交
  commitdata();
}
//设置excel数据循环完毕后处理方法
EXCELIMP.setExcelDataEndLoopHandle(excelDataEndLoopHandle);

//执行导入
EXCELIMP.execute();





46
47
48
49
50
51
52
临时表场景
临时表导入方式，主要是解决大数据量数据导入，利用数据库的功能，作批量的数据检查。把非法的数据保留在
临时表，作最终的错误数据的输出

根据errtype 输出 1 出错 2 忽略 数据 输出至 excel

临时表的结构，按列头定义映射建立数据表。另外，临时表结构要求，必须建立以下几个字段，用于输出出错数据所用

字段中文	字段名	字段类型
批次id	dynamicid	varchar 50
导入员	mbcode	int8
错误类型	errtype	int4
错误信息	errmsg	varchar
js
//注： 此部分只是flycode中的片断

load("importutils");

//临时表名称
var tempTableName = 'kx_kq_product_temp';
var insertTempTableSQL = "insert into ...";

var excelRowDataHandle = function(exceldata, customdata){
    //TODO 按批把excel数据写入至临时表 参考按批提交数据
}

//设置数据行处理
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//excel数据循环完毕后
var excelDataEndLoopHandle = function() {
  //标记临时表出错数据 //此部分可以调用存储过程来处理 //处理错误数据标记完成后
  //调用去处理生成临时表的出错数据输出
  //SELECT * FROM " + tempTableName + " WHERE dynamicid = :dynamicid and mbcode = :mbcode and errtype > 0; 分页输出错误数据至excel
  EXCELIMP.dealTemplateData(tempTableName);
}
//设置excel数据循环完毕后处理方法
EXCELIMP.setExcelDataEndLoopHandle(excelDataEndLoopHandle);

//执行导入
EXCELIMP.execute();




25
26
27
主从数据导入场景
规范列头，如：订单与订单明细导入
以订单号作为一批数据，进行提交
以一个订单，对明细数据进行业务检查
对于一个订单数据，有业务错误，可通过出错记录API，进行处理
js
//注： 此部分只是flycode中的片断

load("importutils");

//标题列映射定义 //定义了主表及明细表需要导入的数据列的映射关系
var titlemappings = [
  {"column": "订单编号","field": "ordercode", "type": "String"},
  {"column": "订单名称","field": "ordername", "type": "String"},
  {"column": "客户名称","field": "customername", "type": "String"},
  {"column": "产品","field": "productname", "type": "String"},
  {"column": "价格","field": "price", "type": "String"},
  {"column": "数量","field": "amount", "type": "String"}
];

//设置标题映射
EXCELIMP.setTitleMapping(titlemappings);

//批次号获取
var dynamicid = EXCELIMP.dynamicid;

//临时变量定义
//主数据
var masterdata = {};
//明细数据
var details = [];

//excel数据存储区
var exceldatas = [];
//执行语句的存储
var execsqls = [];

var orderInsertSql = "insert mastertable ...";
var orderDetailInsertSql = "insert detailtable ....";

var batchCommitData = function() {
    if(!!masterdata && details.length >0) {
      //TODO 是由 masterdata和details  数据检查， 进行处理出execsqls 进行提交
      //var execsql =  {sql: "",param:{}}; execsqls.push(execsql);
        EXCELIMP.commitData(execsqls,exceldatas);//是否能有事务处理？
    }
    //清空
    masterdata = {};
    details = [];
    exceldatas = [];
}

//excel数据行处理，参数传入excel数据行及自定义的参数入参
var excelRowDataHandle = function(exceldata, customdata,sheetname,sheetrownum,rowdata)  {
  //主从模式处理 //根据当前行的订单编码，判断是否为同一个订单数据
  if(!!masterdata && !!masterdata["ordercode"] && exceldata["ordercode"] != masterdata["ordercode"]) {
    //上一次的数据与当前的数据并非同一主数据
    batchCommitData();
  }
  //如果没有数据问题，即把数据加入至临时变量
  masterdata= {"ordercode": exceldata["ordercode"], "ordername": exceldata["ordername"]};//组装主数据表数据
  var detail = execldata;//明细数据 自行组装处理需要字段，赋予 detail
  details.push(detail);
  exceldatas.push(rowdata);
}

//设置数据行检查
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//excel数据循环完毕后
var excelDataEndLoopHandle = function() {
  //把余下未提交的数据，进行提交 主从数据
  batchCommitData();
  //TODO 后续，可执行其他非导入处理
}

//执行导入
EXCELIMP.execute();





60
61
62
63
64
65
66
67
68
69
70
71
72
前端导入场景
用于小批量数据，用于直接把导入数据展示在表单上，进行编辑，再由表单，提交。如：订单明细导入、费用明细导入等。

读取excel里数据，根据列头映射拿到excel数据，每行获取
根据输出的列表定义，把excel数据调整成，列表定义的输出字段 (相当于进行一个数据请求，一个列表输出)
js

load("importutils");

//设置为前端导入模式
EXCELIMP.setFrontImp(true);

//标题列映射定义
var titlemappings = [
  {"column": "产品编码","field": "productcode", "type": "String"},
  {"column": "产品名称","field": "productname", "type": "String"},
  {"column": "产品简称","field": "shortname", "type": "String"},
  {"column": "产品品牌","field": "productbrand", "type": "String"},
  {"column": "建议零售价（元）","field": "retailprice", "type": "String"}
]

//设置标题映射
EXCELIMP.setTitleMapping(titlemappings);

//结果数据
var outdata = [];
var productnames = [];

//excel数据行处理，参数传入excel数据行及自定义的参数入参
var excelRowDataHandle = function(exceldata, customdata)  {
  //读取exceldata转换为要输出的列表的数据集
  //业务处理 把excel数据
  outdata.push(exceldata);
  productnames.push(exceldata["productname"]);
}

EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//执行
EXCELIMP.execute();

var _f_imp_trans_data2map = function(objdatalist) {
    var _obj_data = {};
    if(!!objdatalist && objdatalist.length > 0) {
      for(var _i =0; _i<objdatalist.length; _i++) {
          _obj_data[objdatalist[_i].text]=objdatalist[_i].key;
      }
    }
    return _obj_data;
}

var dbProducts = [];
//根据产品名称，进行查询数据库，查出产品id数据
if(productnames != null && productnames.length>0) {
  dbProducts = select id as key,productname as text,productcode from kx_kq_product where productname in ({productnames}) norule;
}

var c_product_map = _f_imp_trans_data2map(dbProducts);

for(var i=0; i< outdata.length; i++) {
  //产品id赋值
  outdata[i].id = c_product_map[outdata[i].productname];
}

//列表输出
OUT.kx_kq_product = outdata;





60
多sheet页场景 (规范列头)
解决不同sheet，不同列头，处理不同数据的导入

sheet名称，不能随意调整
解决不同sheet列头导入。
可以在sheet变化时，重置列头映射
根据当前不同的sheet名称，进行不同的业务逻辑处理
js
//注： 此部分只是flycode中的片断

load("importutils");

//sheet1 列头映射
var titlemappings1 = [
    {"column": "产品编码","field": "productcode", "type": "String"},
    {"column": "产品名称","field": "productname", "type": "String"},
];

//sheet2 列头映射
var titlemapping2 = [
    {"column": "产品编码","field": "productcode", "type": "String"},
    {"column": "建议零售价（元）","field": "retailprice", "type": "String"}
];

//sheet开始函数注入，动态调整列头映射
var sheetDataStartLoopHandle = function(sheetname) {
  //处理的是把列头重置处理
  if(sheetname == "sheet1") {
    EXCELIMP.setTitleMapping(titlemappings1);
  } else if(sheetname == "sheet2") {
    EXCELIMP.setTitleMapping(titlemappings2);
  }
}

EXCELIMP.setSheetDataStartLoopHandle(sheetDataStartLoopHandle);

//excel数据行处理，参数传入excel数据行及自定义的参数入参
var excelRowDataHandle = function(exceldata, customdata, sheetname, sheetrownum,rowdata){
  //数据检查 //根据不同sheetname，进行业务数据处理
}
//设置数据行处理
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//excel sheet数据循环完毕
var sheetDataEndLoopHandle = function(sheetname, sheetrownum) {
  //把余下的sheet数据提交
}
EXCELIMP.setSheetDataEndLoopHandle(sheetDataEndLoopHandle);

//excel数据循环完毕后
var excelDataEndLoopHandle = function() {
  //在此可以做数据提交，或者什么都不处理
  FLY.log("==== excel data end loop handle ====");
  //或者处理其他的非导入的功能。。如流程、发邮件、消息等
}
//设置excel数据循环完毕后处理方法
EXCELIMP.setExcelDataEndLoopHandle(excelDataEndLoopHandle);

//执行数据导入
EXCELIMP.execute();





46
47
48
49
50
51
52
非规范列头导入场景
不是规范列头的excel数据

逐行读取excel数据

传入给行数据处理的exceldata 是一个 List数组数据

根据数组序号，去获取每个单元格的数据
例如，导入以下的数据



js
//注： 此部分只是flycode中的片断

load("importutils");

var masterobj = {
    "saledept": "销售部门",
  "salesman": "业务员",
  "billnumber": "单据编号",
  "supplier": "供方",
  "buyer": "购方",
  "buyercontact": "购方联系人",
  "suppliercontact": "供方联系人",
  "buyerphone": "购方联系电话",
  "supplierphone": "供方联系电话",
  "buyeraddress":"购方收货地址",
  "totalnum": "总数量",
  "totalprice": "总金额"
}

var details = [];
var detailstart = false;

//数据处理 //进行业务性检查，及判断，进行那些数据提交操作
var dealData = function(exceldata, customdata, sheetname, rownum) {
  //检查忽略策略处理
  //进行数据处理 //如果过程处理中，有业务检查出错，可直接处理出错调用
  FLY.log("sheetname==="+sheetname);
  FLY.log("rownum==="+rownum);
  FLY.log("exceldata==="+exceldata);

  if(rownum == 1) {
    //销售部门
    masterobj.saledept = exceldata[0];
    masterobj.salesman = exceldata[2];
    masterobj.billnumber = exceldata[4];
  }

  if(rownum == 2) {
    masterobj.supplier = exceldata[1];
    masterobj.buyer = exceldata[4];
  }

  if(rownum == 3) {
    masterobj.buyercontact = exceldata[4];
  }

  if(rownum == 4) {
    masterobj.suppliercontact = exceldata[1];
    masterobj.buyerphone = exceldata[4];
  }

  if(rownum == 5) {
    masterobj.supplierphone = exceldata[1];
    masterobj.buyeraddress = exceldata[4];
  }

  if(exceldata[0] == "产品品称" && exceldata[1] == "产品规格") {
    detailstart = true;
  }

  //通过判断是否合计，来判断
  if(exceldata[0] == "合计") {
    masterobj.totalnum = exceldata[3];
    masterobj.totalprice = exceldata[5];
    detailstart = false;
  }

  if(rownum > 6 && detailstart) {
    //明细数据
    var detail = {};
    detail.productname = exceldata[0];
    detail.spec = exceldata[1];
    detail.number = exceldata[2];
    detail.amount = exceldata[3];
    detail.unitprice = exceldata[4];
    detail.price = exceldata[5];
    detail.note = exceldata[6];
    details.push(detail);
  }
}

//excel数据行处理，参数传入excel数据行及自定义的参数入参
var excelRowDataHandle = function(exceldata, customdata, sheetname, sheetrownum){
  var check_res = checkData(exceldata);
  if(!!check_res) {
    //检查不通过，进行错误记录
    //EXCELIMP.errRecord(exceldata, check_res);
  } else {
    excelrow++;
    dealData(exceldata, customdata, sheetname, sheetrownum);
  }
}

//设置数据行处理
EXCELIMP.setExcelRowDataHandle(excelRowDataHandle);

//excel sheet数据循环完毕
var sheetDataEndLoopHandle = function(sheetName, sheetRowNum) {
  //提交数据
}
EXCELIMP.setSheetDataEndLoopHandle(sheetDataEndLoopHandle);

//执行原生数据导入
EXCELIMP.execute("2");

3.3.4 Excel导出
3.3.4.1 Excel导出

3.3.3.2.1 Excel导出过程分解
3.3.3.2.2 Excel导出API
3.3.3.2.3 Excel导出场景例子
3.3.3.2.4 Excel游标导出场景例子
3.3.4.1 Excel导出
支持大数据量，分页处理导出
支持复杂多级列头定义
支持列的输出，按照类型，解决数字类型的问题
支持输出的数据，在写excel前，可进行数据调整。或者较验数据是否重复去重处理
支持在flycode中，定义局部变量，进行数据缓存，以做数据调整转换使用
3.3.4.1.1 导出执行过程分解
执行过程图


入参介绍
json
{
     "expfile": {//导出对象
        "sheetname": "产品",
        "filename": "产品.xlsx",
        "filetype": "1",//导出文件类型 1 excel //新版本只处理excel
        "__fields": [//导出列过滤
            "productcode",
            "productname"
        ]
    },
    "customer-param": {
        //自定义入参， IDE中定义的入参对象
    }
}



13
14
3.3.4.1.2 Excel导出API
加载
初始化加载导出处理类

js
//加载导出处理类 EXCELEXP
load("exportutils");
1
2
获取当前导出的批次id
js
var dynamicid = EXCELEXP.dynamicid;
1
入参获取
js
//入参
var inParam = EXCELEXP.getInputParam();
1
2
导出分页大小设置
js
//设置每次分页的大小
EXCELEXP.setPageSize(500);
1
2
设置导出数据总数处理语句
js

var countSql = "select count(*) from table where ...";

//设置导出计算数量的语句
EXCELEXP.setQueryCountSql(countSql);

设置导出数据分页语句
js

var pageQuerySql = "SELECT * from table where ... limit :limit offset :offset";

//设置导出的查询语句
EXCELEXP.setPageQuerySql(pageQuerySql);

设置导出数据语句参数变量
js

//查询参数，可能需要根据入参参数，再进行二次处理
var queryParam = inParam.kx_kq_product;
//设置查询参数，注：不包括分页参数，分页参数，由java代码，去赋值
EXCELEXP.setQueryParam(queryParam);

数据调整处理函数注入 (非必要)
js
//查询出来数据，进行二次转换,如果不需要进行二次转换，可以不用写 //传入的为一行数据，进行数据调整
var dataAdjustHandle = function(data) {
  //data["status"] = "进行转换";
  return data;
}
//设置调整数据方法
EXCELEXP.setDataAdjustHandle(dataAdjustHandle);

6
7
执行导出
js
//执行导出
EXCELEXP.execute();
.3.4.1.3 场景例子
数据导出例子
js
//注： 此部分只是flycode中的片断

load("exportutils");

//标题列映射定义
var titlemappings = [
    {"column": "产品编码","field": "productcode", "type": "String"},
    {"column": "产品名称","field": "productname", "type": "String"},
    {"column": "建议零售价（元）","field": "retailprice", "type": "double"},
    {"column": "状态","field": "status", "type": "String"},
    {"column": "新品有效期","field": "validityperiod", "type": "Date"}
];

//设置标题映射
EXCELEXP.setTitleMapping(titlemappings);

//设置每次分页的大小
EXCELEXP.setPageSize(500);

//入参
var inParam = EXCELEXP.getInputParam();

var countSql = "select count(*) from kx_kq_product where 1=1 and objtype = 1";

if(!!inParam.kx_kq_product.productname){
    countSql = countSql + " and productname like CONCAT(CONCAT('%',REPLACE(REPLACE(:productname, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ";
}
if(!!inParam.kx_kq_product.status) {
  countSql = countSql + "and status =:status ";
}

//设置导出计算数量的语句
EXCELEXP.setQueryCountSql(countSql);

var pageQuerySql = "SELECT kp.id,kp.productcode,kp.productname,kp.retailprice,kp.validityperiod,kp.status FROM kx_kq_product kp where 1=1 and kp.objtype = 1 ";
if(!!inParam.kx_kq_product.productname){
    pageQuerySql = pageQuerySql + " and kp.productname like CONCAT(CONCAT('%',REPLACE(REPLACE(:productname, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ";
}
if(!!inParam.kx_kq_product.status) {
  pageQuerySql = pageQuerySql + " and kp.status=:status ";
}
pageQuerySql = pageQuerySql + " limit :limit offset :offset ";

//设置导出的查询语句
EXCELEXP.setPageQuerySql(pageQuerySql);

//查询参数，可能需要根据入参参数，再进行二次处理
var queryParam = inParam.kx_kq_product;
//设置查询参数，注：不包括分页参数，分页参数，由java代码，去赋值
EXCELEXP.setQueryParam(queryParam);

//缓存数据
var c_status = {"1": "启用", "2": "停用", "": ""};

//查询出来数据，进行二次转换,如果不需要进行二次转换，可以不用写 //传入的为一行数据，进行数据调整
var dataAdjustHandle = function(data) {
  //注：可以在此用全局变量，记着输出的数据id，用于判断，是否重复输出 如果判断是重复输出，则返回null
  //如果说对于输出数据有比较严格，不能有脏读或实效性的，先写临时表，再用临时表导出
  data["status"] = c_status[data["status"]];
  return data;
}
//设置调整数据方法
EXCELEXP.setDataAdjustHandle(dataAdjustHandle);

//执行导出
EXCELEXP.execute();





60
61
62
63
64
65
66
3.3.4.1.4 游标场景例子
说明

与flycode导出写法一样，差别，只在于语句不用分页和导出的API
查询的语句不需要分页
js
var pageQuerySql = "SELECT kp.id,kp.productcode,kp.productname,kp.shortname,kp.boxweight,kp.unitconverrate,kp.distributionnorm,kp.singlenorm,kp.boxfactor, kp.distributionbarcode, kp.singlebarcode,kp.retailprice,kp.productpackag,kp.iskeyproduct,kp.validityperiod,kp.status,pc.dicvalue as productcategory,pb.dicvalue as productbrand,du.dicvalue as distributionunit,su.dicvalue as singleunit,kp.minimumorder FROM kx_kq_product kp left join pl_dictionary pc on kp.productcategory = pc.dickey left join pl_dictionary pb on kp.productbrand = pb.dickey left join pl_dictionary du on kp.distributionunit = du.dickey left join pl_dictionary su on kp.singleunit = su.dickey where 1=1 ";
//and kp.objtype = 1 ";
if(!!inParam.kx_kq_product.productname){
FLY.log("入参打印inParam.kx_kq_product.productname===="+inParam.kx_kq_product.productname);
pageQuerySql = pageQuerySql + " and kp.productname like CONCAT(CONCAT('%',REPLACE(REPLACE(:productname, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ";
}
if(!!inParam.kx_kq_product.status) {
pageQuerySql = pageQuerySql + " and kp.status=:status ";
}
pageQuerySql = pageQuerySql + " order by kp.updatetime desc ";

//注：用游标方式，不需要写分页的语句



导出的执行API更换为 EXCELEXP.executeByCursor();
游标导出API

js
//执行导出 cursor
EXCELEXP.executeByCursor();
1
2
数据导出例子
js
/**
用于验证新的导出flycode模式 用游标

例子：产品导出
*/

//加载导出处理类 EXCELEXP
load("exportutils");

//标题列映射定义
var titlemappings = [
  {"column": "产品编码","field": "productcode", "type": "String", "width": ""},
  {"column": "产品名称","field": "productname", "type": "String", "width": "0"},
  {"column": "产品简称","field": "shortname", "type": "String"},
  {"column": "产品品牌","field": "productbrand", "type": "String", "width": "30"},
  {"column": "产品品类","field": "productcategory", "type": "String", "width": "40"},
  {"column": "分销单位","field": "distributionunit", "type": "String", "width": "40"},
  {"column": "单品单位","field": "singleunit", "type": "String", "width": "25"},
  {"column": "单位转换率","field": "unitconverrate", "type": "String", "width": "30"},
  {"column": "是否重点产品","field": "iskeyproduct", "type": "String", "width": "40"},
  {"column": "状态","field": "status", "type": "String", "width": "20"},
  {"column": "箱重（KG）","field": "boxweight", "type": "String", "width": "50"},
  {"column": "经销商起订量","field": "minimumorder", "type": "String", "width": "50"},
  {"column":"规格", "child":[
    {"column": "分销规格","field": "distributionnorm", "type": "String", "width": ""},
    {"column": "单品规格","field": "singlenorm", "type": "String", "width": "0"},
    {"column": "标箱系数","field": "boxfactor", "type": "double"}
  ]},
  {"column": "条码", "child":[
    {"column": "分销条码    ","field": "distributionbarcode", "type": "String", "width": "50"},
    {"column": "单品条码","field": "singlebarcode", "type": "String", "width": "50"}
  ]},
  {"column": "建议零售价（元）","field": "retailprice", "type": "double", "width": "60"},
  {"column": "产品包装","field": "productpackag", "type": "String", "width": "40"},
  {"column": "保质时长（天）","field": "shelflife", "type": "double", "width": "60"},
  {"column": "渠道类型","field": "channeltype", "type": "String", "width": "50"},
  {"column": "新品有效期","field": "validityperiod", "type": "Date", "width": "80"}
];

//设置标题映射
EXCELEXP.setTitleMapping(titlemappings);

//设置每次分页的大小
EXCELEXP.setPageSize(500);

var dynamicid = EXCELEXP.dynamicid;

//入参
var inParam = EXCELEXP.getInputParam();

var countSql = "select count(*) from kx_kq_product where 1=1 ";
//and objtype = 1 ";
if(!!inParam.kx_kq_product.productname){
    countSql = countSql + " and productname like CONCAT(CONCAT('%',REPLACE(REPLACE(:productname, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ";
}
if(!!inParam.kx_kq_product.status) {
  countSql = countSql + "and status =:status ";
}

//设置导出计算数量的语句
EXCELEXP.setQueryCountSql(countSql);

var pageQuerySql = "SELECT kp.id,kp.productcode,kp.productname,kp.shortname,kp.boxweight,kp.unitconverrate,kp.distributionnorm,kp.singlenorm,kp.boxfactor, kp.distributionbarcode, kp.singlebarcode,kp.retailprice,kp.productpackag,kp.iskeyproduct,kp.validityperiod,kp.status,pc.dicvalue as productcategory,pb.dicvalue as productbrand,du.dicvalue as distributionunit,su.dicvalue as singleunit,kp.minimumorder FROM kx_kq_product kp left join pl_dictionary pc on kp.productcategory = pc.dickey left join pl_dictionary pb on kp.productbrand = pb.dickey left join pl_dictionary du on kp.distributionunit = du.dickey left join pl_dictionary su on kp.singleunit = su.dickey where 1=1 ";
//and kp.objtype = 1 ";
if(!!inParam.kx_kq_product.productname){
  FLY.log("入参打印inParam.kx_kq_product.productname===="+inParam.kx_kq_product.productname);
    pageQuerySql = pageQuerySql + " and kp.productname like CONCAT(CONCAT('%',REPLACE(REPLACE(:productname, '%', '/%'), '_', '/_')), '%') ESCAPE '/' ";
}
if(!!inParam.kx_kq_product.status) {
  pageQuerySql = pageQuerySql + " and kp.status=:status ";
}
pageQuerySql = pageQuerySql + " order by kp.updatetime desc ";

//设置导出的查询语句
EXCELEXP.setPageQuerySql(pageQuerySql);

//查询参数，可能需要根据入参参数，再进行二次处理
var queryParam = inParam.kx_kq_product;
//设置查询参数，注：不包括分页参数，分页参数，由java代码，去赋值
EXCELEXP.setQueryParam(queryParam);

//缓存数据
var c_status = {"1": "启用", "2": "停用", "": ""};
var c_iskeyproduct = {"0": "否", "1": "是", "": ""};

//存储已经输出excel数据id，用于判断是否已经存在
var id_cache = [];

//查询出来数据，进行二次转换,如果不需要进行二次转换，可以不用写 //传入的为一行数据，进行数据调整
var dataAdjustHandle = function(data) {
  //注：可以在此用全局变量，记着输出的数据id，用于判断，是否重复输出 如果判断是重复输出，则返回null

  data["status"] = c_status[data["status"]];
  data["iskeyproduct"] = !data["iskeyproduct"] ? '' : c_iskeyproduct[data["iskeyproduct"]];
  data["channeltype"] = "";//json处理出text值
  //data["validityperiod"] = !data["validityperiod"] ? '' : Date.parseDate(data["validityperiod"]).Format("yyyy/MM/dd");

  return data;
}
//设置调整数据方法
EXCELEXP.setDataAdjustHandle(dataAdjustHandle);

//执行导出 cursor
EXCELEXP.executeByCursor();

EXCEL EXPORT API DOC
加载API（ load）
js
load("excelapi");
1
API（EXCEL）文件对象
①创建工作表 addSheet
样例1：

js
var sheet1=EXCEL.addSheet(); //创建一个默认命名为"工作表+序号为1" 的工作表。如果有多个工作表，那么名称会叠加
/*======================或者==================*/
var sheet1 =EXCEL.addSheet("测试工作表");//创建一个命名为"测试工作表"的工作表。

②获取工作表 getSheet
由于存在多个工作表操作的情况，有时候我们需要回到某个工作表再次操作。

样例2：

js
/*================根据下标获取工作表======================*/
var sheet1=EXCEL.getSheet(1); //获取下标为1的工作表对象   （创建工作表，下标是从0开始记录）

/*================根据工作表名称获取工作表======================*/
var sheet1=EXCEL.getSheet("测试工作表"); //获取命名为"测试工作表"的工作表对象

③设置excel的样式
默认设置两个样式:(title 和 default)，样式是在操作单元格或者行数据的时候使用

名称	样式简述
default	默认数据行样式（不加粗、字号14、宋体）
title	默认标题行样式（加粗、字号24、宋体）
增加自定义样式 addStyle

一个excel 只能设置30个以内数量的自定义样式，样式是在操作单元格或者行数据的时候使用

样例：

js
var style={};
style.fontname='宋体';//宋体
style.fontcolor='red';//文字标红
style.size='18';//文字大小
style.backcolor='blue';//背景色为蓝色
EXCEL.addStyle("test",style);//添加自定义样式，每个excel文件只允许存在30个自定义样式（不含默认样式）

6
样式总结：

单元格样式分为单元格样式和单元格内容（字体）样式

单元格样式：
1) 水平对齐 align
属性值	描述
center	默认为居中
left	单元格内容居左
right	单元格内容居右
2) 垂直对齐 verticalAlign
属性值	描述
center	默认为居中
left	单元格内容居左
right	单元格内容居右
3) 边框线 border
属性值	描述
true	带边框线
false	不带边框线
4)单元格内自动换行 wrap
属性值	描述
true	带边框线
false	不带边框线
5)边框线颜色 bordercolor
属性值	描述
red 或者 10	红色
blue 或者 12	蓝色
orange 或者 53	橙色
black 或者 8	黑色
white 或者 9	白色
green 或者 17	绿色
yellow 或者13	黄色
pink或者14	粉色
violet 或者20	紫色
turquoise 或者 15	绿宝石
lavender 或者 46	淡紫
tan 或者 47	晒黑
dark_red 或者 16	深红
light_green 或者 42	淡绿
light_blue 或者 48	淡蓝
light_yellow 或者 43	淡黄
indigo 或者 62	靛青
6) 背景色 backcolor
属性值	描述
red 或者 10	红色
blue 或者 12	蓝色
orange 或者 53	橙色
black 或者 8	黑色
white 或者 9	白色
green 或者 17	绿色
yellow 或者13	黄色
pink或者14	粉色
violet 或者20	紫色
turquoise 或者 15	绿宝石
lavender 或者 46	淡紫
tan 或者 47	晒黑
dark_red 或者 16	深红
light_green 或者 42	淡绿
light_blue 或者 48	淡蓝
light_yellow 或者 43	淡黄
indigo 或者 62	靛青
单元格字体样式：
1) 字体大小 size
单纯是数字，参照word 或者excel 的字体大小。默认值为14。（参照上面的样例）

2) 字体名称 fontname
默认为宋体。（参照上面的样例）

3) 字体颜色 fontcolor
字体颜色，默认为黑色（参照上面的样例）

4) 斜体 italic
默认非斜体。

属性值	描述
true	使用斜体格式
false	非斜体。
删除线strikeout
默认不使用删除线

属性值	描述
true	使用删除线格式
false	非删除线。
下划线 underline
默认不使用下划线

属性值	描述
true	使用下划线格式，默认是单下划线
false	非下划线。
2	如果需要使用双下划线，那么就赋值2
④获取当前所在工作表的最后一行的下标 getCurrentRowNum
由于操作可能存在多行，我们需要知道当前操作进度是在第几行可能用到。

样例3：

js
var  rowIndex=EXCEL.getCurrentRowNum();
1
⑤进度条操作
1) 进度条操作总数 setTotalCount
进度条的更新状态是根据 （操作完成数/操作总数=进度条的进度）。

样例4:

js
EXCEL.setTotalCount(100);
1
2) 更新进度条进度 updateState
样例5：

js
EXCEL.updateState(20);//结合上面setTotalCount的样例，就是当前已经完成20.也就是20/100,进度条更新到20%的状态
1
3) 操作过程可能存在问题更新进度条失败状态 error
样例6：

js
EXCEL.error("xxxx数据不能为空");//更新进度条状态为失败状态，并记录"xxxx数据不能为空"的异常日志
1
⑥操作完成后导出文件 export
样例7：

js
EXCEL.export("人员导出");//那么就会产生一个人员导出的文件流
1
API(sheet) 工作表对象
sheet 工作表对象，如样例1，我们可以创建一个sheet工作表对象，并进行操作

获取当前工作表名称 getSheetName
用于在编写业务时需要获取当前操作工作表的名称。

js
var sheetName= sheet.getSheetName();
1
创建行 addRow
①创建行对象

addRow(index);
index: 数字类型，表示第几行

样例:

js
var sheet1 =EXCEL.addSheet("测试工作表");
var row =sheet1.addRow(0);
1
2
②新增一行数据（一行单元格）
addRow(index, columnList )

index: 数字类型，表示第几行

columnList :一行单元格的属性组成数组

属性 index ，表示单元格是第几列

属性 value ，表示单元格填充内容

属性 style , 单元格样式名称，参照

样例:

js
var sheet1 =EXCEL.addSheet("测试工作表");
var list=[];
var p={};
p.index=0;
p.value='终端信息';
list.push(p);
p={};
p.index=0;
p.value='终端名称';
p.style='default';
list.push(p);
var row1 = sheet2.addRow(0,list);//创建第0行，0列数据为'终端信息',1列数据为'终端名称'的一行数据，其中第一列"终端名称"的样式使用了default 默认行数据格式



③新增一行数据，不需要指定哪一行
addRow(colList,styleName)

colList: 单元格值数组

styleName: 样式名称,一行数据都是使用同一个样式

样例：

js
var sheet1 =EXCEL.addSheet("测试工作表");
var title =[];
title.push('终端编码');
title.push('终端名称');
title.push('终端简称');
sheet.addRow(title,"title");//表头样式使用默认title 样式（加粗、字号24、宋体）

6
获取某一行 getRow
获取某一行的行对象

getRow(int rowNum)

js
var row =sheet.getRow(1);//获取下标为1的行对象
1
合并单元格 merge
① 合并多个单元格 merge([]）
入参为合并单元格的数组， 数组的单个值的格式为：‘开始行，结束行，开始列，结束列’

样例：

js
var test = [];
var cell = '0,0,0,1'; //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。
test.push(cell);
 cell = '0,2,0,1'; //合并开始行为第0行，结束行下标为2的行，开始列第0列，结束列第1列的单元格。
test.push(cell);
sheet.merge(test);//合并这两个单元格

6
②合并多个单元格，并且都加边框线 merge([]，true）
第一入参为合并单元格的数组， 数组的单个值的格式为：‘开始行，结束行，开始列，结束列’

第二入参，设置为true ，表示需要加边框线

样例：

js
var test = [];
var cell = '0,0,0,1'; //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。
test.push(cell);
 cell = '0,2,0,1'; //合并开始行为第0行，结束行下标为2的行，开始列第0列，结束列第1列的单元格。
test.push(cell);
sheet.merge(test,true);//合并这两个单元格

6
③合并一个单元格 merge(value）
value: 格式为：‘开始行，结束行，开始列，结束列’
样例：

js
sheet.merge('0,0,0,1'); //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。
1
④合并一个单元格，加边框线 merge(value,true）
value: 格式为：‘开始行，结束行，开始列，结束列’

true ,表示这个单元格要加上边框线。

样例：


sheet.merge('0,0,0,1'); //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。并加上边框线。
1
设置列宽 setCellWidth
列是属于整个工作表的

sheet.setCellWidth(index,width);

属性 index 列的下标， 第几列，从0开始计算

属性 width 列宽，填写几个汉字就选几个就行。如果实际是超过这个设置数的表格里那一列就会挤一起。

样例：

js
//第一列列宽为80
sheet.setCellWidth(0, 80); //设置列宽
1
2
API(row)行对象
行对象添加单元格。操作单元格。

获取当前行某列单元格对象 getCell
样例:

js
var list=[];
var p={};
p.index=0;
p.value='终端信息';
list.push(p);
var row1 = sheet2.addRow(0,list);//添加了第0行数据
var cell1 =row1.getCell(0);//那么就可以获取当前单元格对象了
var value =cell1.getValue();//获取单元格的值


获取当前行的下标 getCurrentRowIndex
获取当前行的下标，从0开始

样例：


var index= row1.getCurrentRowIndex();//获取下标，知道是第几行。从0开始计算
1
添加单元格 addCell
①添加单元格，默认样式
addCell(index,cellValue);

属性 index 下标，从0开始。

属性cellValue 单元格内容

样例：

js
row1.addCell(0,"标题1");
row1.addCell(1,"标题2");
1
2
②添加单元格，指定样式（必须在开始时就EXCEL.addStyle 添加进去的）
addCell(index,cellValue,styleName);

属性 index 下标 ，从0开始

属性 cellValue 单元格内容

属性 styleName 指定样式名称

样例：

js
var cell1=row1.addCell(0,"标题1","title");//指定默认表头样式
var cell2 =row1.addCell(1,"标题2","title");
1
2
添加一行单元格 addCells
addCells(cellList,styleName);

属性 cellList 单元格值的数组

属性 styleName 指定的样式名称

样例：

js
var list=[];
list.push('标题1');
list.push('标题2');
row1.addCells(list,"title");

4
设置行高 setHigh
setHigh(int)

样例：

js
row = sheet.addRow(6);
row.setHigh(30);
1
2
API(cell) 单元格对象
获取当前单元格的下标 getCurrentCellIndex
样例:

js
var cellIndex=cell.getCurrentCellIndex();
1
获取当前单元格所在行的下标 getCurrentRowIndex
样例:

js
var rowIndex =cell.getCurrentRowIndex();
1
获取当前单元格的值 getValue
字符串格式

样例：

js
var value= cell.getValue();
1
样例
样例1
js
/**
场景： 导出终端信息 自定义flycode测试
 */

load("excelapi");

var sheet = EXCEL.addSheet('测试工作表');

var getCount = select count(1)as count from kx_kq_store;
EXCEL.setTotalCount(getCount[0].count);
var data = select * from kx_kq_store;
var row = sheet.addRow(0); //自定义标题
row.addCell(0,"终端信息")

row = sheet.addRow(1);
row.addCell(0,'单元格1' );
row.addCell(1,'单元格2');
for (var i = 0; i < data.length; i++) {
    row = sheet.addRow(i + 2);
    row.addCell(0,data[i].storecode);
    row.addCell(1,data[i].storename);
}
var test = [];
var cell = '0,0,0,1'; //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。
test.push(cell);
sheet.merge(test);

/**********************多个sheet写法 EXCEL.addSheet*************************************/
var sheet2 = EXCEL.addSheet('测试工作表2');
/*
 *********************方法一 创建一个行 sheet2.addRow(index) ******************************
var row1 = sheet2.addRow(0); //自定义标题
row1.addCell(0,"终端信息")
*/

/**********************方法二  创建一行 ，使用 sheet2.addRow(index , cellArrayList)*********************************/
var list=[];
var p={};
p.index=0;
p.value='终端信息';
list.push(p);
var row1 = sheet2.addRow(0,list);
//----------------------------分隔符----------------------------------

row1 = sheet2.addRow(1);
row1.addCell(0,'单元格1');
row1.addCell(1,'单元格2');
for (var i = 0; i < data.length; i++) {
    row1 = sheet2.addRow(i + 2);
    row1.addCell(0,data[i].storecode);
 var cell=   row1.addCell(1,data[i].storename );

}
EXCEL.export("终端信息");





46
47
48
49
50
51
52
53
54
样例2
js
/**
场景： 导出终端信息 自定义flycode测试
 */

load("excelapi ");

var sheet = EXCEL.addSheet('测试工作表');

//var getCount = select count(1) as count from kx_kq_store;

var style={};
style.fontcolor='red';//文字标红
style.size='18';//文字大小
style.backcolor='blue';//背景色为蓝色
EXCEL.addStyle("test",style);//添加自定义样式，每个excel文件只允许存在30个自定义样式（不含默认样式）
/**内置默认两种格式
 **名称：default     默认数据行样式（不加粗、字号14、宋体）
 **名称: title       默认标题行样式（加粗、字号24、宋体）
***/
var title =[];
title.push('终端编码');
title.push('终端名称');
title.push('终端简称');
sheet.addRow(title,"title");//默认title 样式（加粗、字号24、宋体）
var data = select * from kx_kq_store;
for (var i = 0; i < data.length; i++) {
     var col =[];
      col.push(data[i].storecode);
      col.push(data[i].storename);
      col.push(data[i].storeshortname);
      var row = sheet.addRow(col,"test");//使用自定义样式

}
EXCEL.export("终端信息");




25
26
27
28
29
30
31
32
33
34
样例3
效果图：



代码：

js

load("excelapi ");//加载api
var sheet = EXCEL.addSheet('订单模板');
var style = {};
style.size = '20'; //文字大小
style.bold = 'true'; //加粗
style.wrap = 'true'; //自动换行
EXCEL.addStyle('标题1', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'false'; //不加粗
style.backcolor = 'yellow'; //黄色
style.wrap = 'true'; //自动换行
EXCEL.addStyle('黄色不加粗不加边框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; // 加粗
style.backcolor = 'yellow'; //黄色
style.border = 'true';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('黄色加粗加边框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; // 加粗
style.backcolor = 'yellow'; //黄色
style.border = 'false';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('黄色加粗不加边框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; // 加粗
style.border = 'false';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('加粗不加边框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; // 加粗
style.border = 'true';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('加粗加边框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'false'; //不加粗
style.border = 'false';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('不加粗不加边框', style);

style = {};
style.size = '16'; //文字大小
style.bold = 'true'; //不加粗
style.border = 'false';
EXCEL.addStyle('16号加粗不加边框', style);

style = {};
style.size = '16'; //文字大小
style.bold = 'true'; //不加粗
style.border = 'false';
style.align = 'left';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('16号加粗不加边框字体靠左', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; //不加粗
style.border = 'true';

style.fontcolor = 'red';
style.wrap = 'true'; //自动换行
EXCEL.addStyle('12号红字加粗加框', style);

style = {};
style.size = '12'; //文字大小
style.bold = 'true'; //不加粗
style.border = 'true';
style.align = 'left';
style.fontcolor = 'red';
style.backcolor = 'yellow'; //黄色
style.wrap = 'true'; //自动换行
EXCEL.addStyle('12号黄色红字加粗加框', style);

var row = sheet.addRow(0);
row.setHigh(160);//设置行高
sheet.merge('0,1,0,6');
row = sheet.getRow(0);
row.addCell(0, '上海妙可蓝多食品科技股份有限公司\r\n   订  购  单', '标题1');

row = sheet.addRow(2);

row.addCell(0, '销售部门：零售事业部', '加粗不加边框');
row.addCell(1, '业务员:', '加粗不加边框');
row.addCell(2, '于相国', '黄色不加粗不加边框');
sheet.merge('2,2,3,6');
row = sheet.getRow(2);
row.addCell(3, '单据编号：', '16号加粗不加边框字体靠左');

row = sheet.addRow(3);
//row=sheet.getRow(3);
row.addCell(0, '供方：', '黄色加粗加边框');
row.addCell(1, '上海妙可蓝多食品科技股份有限公司', '黄色加粗加边框')
row.addCell(2, '购  方:', '黄色加粗加边框')
row.addCell(3, '上海嘉寓商贸有限公司', '黄色加粗加边框')
row = sheet.addRow(4);
row.addCell(2, '联系人：', '黄色加粗加边框')
row.addCell(3, '孙菽英', '黄色加粗加边框')
row = sheet.addRow(5);
row.addCell(0, '联系人：', '黄色加粗加边框')
row.addCell(1, ' ', '黄色加粗加边框')
row.addCell(2, '联系电话：', '黄色加粗加边框')
row.addCell(3, '133 9103 7161 ', '黄色加粗加边框')
row = sheet.addRow(6);
var value = [];
value.push('电话：');
value.push(' ');
value.push('收货地址:');
value.push('上海市浦东新区川南奉公路');
row.addCells(value, '黄色加粗加边框');
row = sheet.addRow(7);
row.setHigh(35);//设置行高
value = [];
value.push('产品品称');
value.push('产品规格');
value.push('编号');
value.push('数量（箱）');
value.push('箱价');
value.push('金额（元）');
value.push('备注');
row.addCells(value, '加粗加边框');

//加载订单详情信息
var data = select t.productname, (select a.distributionnorm from kx_kq_product a where a.productcode = t.productcode)as distributionnorm, t.productcode, t.batchcount, t.price, t.batchcount * t.price as amount from kx_order_detail t where t.orderid = '1197402658797916160';
for (var i = 0; i < data.length; i++) {
    row = sheet.addRow(8 + i);
    row.addCell(0, data[i].productname, '加粗加边框');
    row.addCell(1, data[i].distributionnorm, '黄色加粗加边框');
    row.addCell(2, data[i].productcode, '黄色加粗加边框');
    row.addCell(3, data[i].batchcount, '黄色加粗加边框');
    row.addCell(4, data[i].price, '黄色加粗加边框');
    row.addCell(5, data[i].amount, '黄色加粗加边框');
    row.addCell(6, ' ', '黄色加粗加边框');
}

var nowRowNum = row.getCurrentRowIndex(); //获取当前的行数
nowRowNum=nowRowNum+1;
row = sheet.addRow(nowRowNum);
row.addCell(0, '合计', '12号红字加粗加框');
row.addCell(1, ' ', '12号黄色红字加粗加框');
row.addCell(2, ' ', '12号黄色红字加粗加框');
row.addCell(3, '2205', '12号黄色红字加粗加框');
row.addCell(4, ' ', '12号黄色红字加粗加框');
row.addCell(5, '528026.8', '12号黄色红字加粗加框');
row.addCell(6, '754324', '12号黄色红字加粗加框');
nowRowNum=nowRowNum+1;
var  v_collect=nowRowNum;
row = sheet.addRow(nowRowNum);
 value = [];
value.push('总汇款金额（元）');
value.push(' ');
row.addCells(value,'加粗加边框');

nowRowNum=nowRowNum+1;
var  v_collect1=nowRowNum;
row = sheet.addRow(v_collect1);
 value = [];
value.push('交货条件');
value.push('购方全额预付货款，供方接到货款后安排出货。');
row.addCells(value,'加粗加边框');

nowRowNum=nowRowNum+1;
var  v_collect2=nowRowNum;
row = sheet.addRow(v_collect2);
row.setHigh(66);//设置行高
value = [];
value.push('汇款帐户信息');
value.push('公司名称：上海妙可蓝多食品科技股份有限公司 \r\n开户银行：光大银行上海金桥支行   \r\n帐号： 76300 188 000 \r\n');
row.addCells(value,'加粗加边框');

nowRowNum=nowRowNum+1;
var  v_collect3=nowRowNum;
row = sheet.addRow(v_collect3);

value = [];
value.push('备注');
value.push('妙可蓝多奶酪订单');
row.addCells(value,'加粗加边框');

/**合并单元格***/
var merBorder = [];
var range = '3,4,0,0'; //合并开始行为第0行，结束行第0行，开始列第0列，结束列第1列的单元格。
merBorder.push(range);
range = '3,4,1,1';
merBorder.push(range);
range = '3,3,3,6';
merBorder.push(range);
range = '4,4,3,6';
merBorder.push(range);
range = '5,5,3,6';
merBorder.push(range);
range = '6,6,3,6';
merBorder.push(range);
range = v_collect+','+v_collect+',1,6';
merBorder.push(range);

range = v_collect1+','+v_collect1+',1,6';
merBorder.push(range);
range = v_collect2+','+v_collect2+',1,6';
merBorder.push(range);
range = v_collect3+','+v_collect3+',1,6';
merBorder.push(range);
sheet.merge(merBorder, true);

/***设置列宽***/
sheet.setCellWidth(0, 80); //设置列宽
sheet.setCellWidth(1, 50); //设置列宽
sheet.setCellWidth(2, 35); //设置列宽
sheet.setCellWidth(3, 25); //设置列宽
sheet.setCellWidth(5, 25); //设置列宽
EXCEL.setTotalCount(1);
EXCEL.export("订单");
